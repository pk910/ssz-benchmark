// Code generated by fastssz. DO NOT EDIT.
// Hash: 83c33f137b77cb85cd57adc41f431210a4c8cf3ef39341fc086a319a1a6fa034
// Version: 2.0.0
package fastssz

import (
	ssz "github.com/ferranbt/fastssz"
)

// MarshalSSZ ssz marshals the Fork object
func (f *Fork) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(f)
}

// MarshalSSZTo ssz marshals the Fork object to a target array
func (f *Fork) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf

	// Field (0) 'PreviousVersion'
	dst = append(dst, f.PreviousVersion[:]...)

	// Field (1) 'CurrentVersion'
	dst = append(dst, f.CurrentVersion[:]...)

	// Field (2) 'Epoch'
	dst = ssz.MarshalValue(dst, uint64(f.Epoch))

	return
}

// UnmarshalSSZ ssz unmarshals the Fork object
func (f *Fork) UnmarshalSSZ(buf []byte) error {
	return ssz.UnmarshalSSZ(f, buf)
}

// UnmarshalSSZTail unmarshals the Fork object and returns the remaining bufferº
func (f *Fork) UnmarshalSSZTail(buf []byte) (rest []byte, err error) {
	size := len(buf)
	fixedSize := f.fixedSize()
	if size < fixedSize {
		return nil, ssz.ErrSize
	}

	// Field (0) 'PreviousVersion'
	buf = ssz.UnmarshalFixedBytes(f.PreviousVersion[:], buf)

	// Field (1) 'CurrentVersion'
	buf = ssz.UnmarshalFixedBytes(f.CurrentVersion[:], buf)

	// Field (2) 'Epoch'
	{
		var val uint64
		val, buf = ssz.UnmarshallValue[uint64](buf)
		f.Epoch = Epoch(val)
	}

	return buf, nil
}

// fixedSize returns the fixed size of the Fork object
func (f *Fork) fixedSize() int {
	return int(16)
}

// SizeSSZ returns the ssz encoded size in bytes for the Fork object
func (f *Fork) SizeSSZ() (size int) {
	size = f.fixedSize()
	return
}

// HashTreeRoot ssz hashes the Fork object
func (f *Fork) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(f)
}

// HashTreeRootWith ssz hashes the Fork object with a hasher
func (f *Fork) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'PreviousVersion'
	hh.PutBytes(f.PreviousVersion[:])

	// Field (1) 'CurrentVersion'
	hh.PutBytes(f.CurrentVersion[:])

	// Field (2) 'Epoch'
	hh.PutUint64(uint64(f.Epoch))

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the Fork object
func (f *Fork) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(f)
}

// MarshalSSZ ssz marshals the Checkpoint object
func (c *Checkpoint) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(c)
}

// MarshalSSZTo ssz marshals the Checkpoint object to a target array
func (c *Checkpoint) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf

	// Field (0) 'Epoch'
	dst = ssz.MarshalValue(dst, uint64(c.Epoch))

	// Field (1) 'Root'
	dst = append(dst, c.Root[:]...)

	return
}

// UnmarshalSSZ ssz unmarshals the Checkpoint object
func (c *Checkpoint) UnmarshalSSZ(buf []byte) error {
	return ssz.UnmarshalSSZ(c, buf)
}

// UnmarshalSSZTail unmarshals the Checkpoint object and returns the remaining bufferº
func (c *Checkpoint) UnmarshalSSZTail(buf []byte) (rest []byte, err error) {
	size := len(buf)
	fixedSize := c.fixedSize()
	if size < fixedSize {
		return nil, ssz.ErrSize
	}

	// Field (0) 'Epoch'
	{
		var val uint64
		val, buf = ssz.UnmarshallValue[uint64](buf)
		c.Epoch = Epoch(val)
	}

	// Field (1) 'Root'
	buf = ssz.UnmarshalFixedBytes(c.Root[:], buf)

	return buf, nil
}

// fixedSize returns the fixed size of the Checkpoint object
func (c *Checkpoint) fixedSize() int {
	return int(40)
}

// SizeSSZ returns the ssz encoded size in bytes for the Checkpoint object
func (c *Checkpoint) SizeSSZ() (size int) {
	size = c.fixedSize()
	return
}

// HashTreeRoot ssz hashes the Checkpoint object
func (c *Checkpoint) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(c)
}

// HashTreeRootWith ssz hashes the Checkpoint object with a hasher
func (c *Checkpoint) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'Epoch'
	hh.PutUint64(uint64(c.Epoch))

	// Field (1) 'Root'
	hh.PutBytes(c.Root[:])

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the Checkpoint object
func (c *Checkpoint) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(c)
}

// MarshalSSZ ssz marshals the BeaconBlockHeader object
func (b *BeaconBlockHeader) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(b)
}

// MarshalSSZTo ssz marshals the BeaconBlockHeader object to a target array
func (b *BeaconBlockHeader) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf

	// Field (0) 'Slot'
	dst = ssz.MarshalValue(dst, uint64(b.Slot))

	// Field (1) 'ProposerIndex'
	dst = ssz.MarshalValue(dst, uint64(b.ProposerIndex))

	// Field (2) 'ParentRoot'
	dst = append(dst, b.ParentRoot[:]...)

	// Field (3) 'StateRoot'
	dst = append(dst, b.StateRoot[:]...)

	// Field (4) 'BodyRoot'
	dst = append(dst, b.BodyRoot[:]...)

	return
}

// UnmarshalSSZ ssz unmarshals the BeaconBlockHeader object
func (b *BeaconBlockHeader) UnmarshalSSZ(buf []byte) error {
	return ssz.UnmarshalSSZ(b, buf)
}

// UnmarshalSSZTail unmarshals the BeaconBlockHeader object and returns the remaining bufferº
func (b *BeaconBlockHeader) UnmarshalSSZTail(buf []byte) (rest []byte, err error) {
	size := len(buf)
	fixedSize := b.fixedSize()
	if size < fixedSize {
		return nil, ssz.ErrSize
	}

	// Field (0) 'Slot'
	{
		var val uint64
		val, buf = ssz.UnmarshallValue[uint64](buf)
		b.Slot = Slot(val)
	}

	// Field (1) 'ProposerIndex'
	{
		var val uint64
		val, buf = ssz.UnmarshallValue[uint64](buf)
		b.ProposerIndex = ValidatorIndex(val)
	}

	// Field (2) 'ParentRoot'
	buf = ssz.UnmarshalFixedBytes(b.ParentRoot[:], buf)

	// Field (3) 'StateRoot'
	buf = ssz.UnmarshalFixedBytes(b.StateRoot[:], buf)

	// Field (4) 'BodyRoot'
	buf = ssz.UnmarshalFixedBytes(b.BodyRoot[:], buf)

	return buf, nil
}

// fixedSize returns the fixed size of the BeaconBlockHeader object
func (b *BeaconBlockHeader) fixedSize() int {
	return int(112)
}

// SizeSSZ returns the ssz encoded size in bytes for the BeaconBlockHeader object
func (b *BeaconBlockHeader) SizeSSZ() (size int) {
	size = b.fixedSize()
	return
}

// HashTreeRoot ssz hashes the BeaconBlockHeader object
func (b *BeaconBlockHeader) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(b)
}

// HashTreeRootWith ssz hashes the BeaconBlockHeader object with a hasher
func (b *BeaconBlockHeader) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'Slot'
	hh.PutUint64(uint64(b.Slot))

	// Field (1) 'ProposerIndex'
	hh.PutUint64(uint64(b.ProposerIndex))

	// Field (2) 'ParentRoot'
	hh.PutBytes(b.ParentRoot[:])

	// Field (3) 'StateRoot'
	hh.PutBytes(b.StateRoot[:])

	// Field (4) 'BodyRoot'
	hh.PutBytes(b.BodyRoot[:])

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the BeaconBlockHeader object
func (b *BeaconBlockHeader) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(b)
}

// MarshalSSZ ssz marshals the SignedBeaconBlockHeader object
func (s *SignedBeaconBlockHeader) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(s)
}

// MarshalSSZTo ssz marshals the SignedBeaconBlockHeader object to a target array
func (s *SignedBeaconBlockHeader) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf

	// Field (0) 'Message'
	if s.Message == nil {
		s.Message = new(BeaconBlockHeader)
	}
	if dst, err = s.Message.MarshalSSZTo(dst); err != nil {
		return
	}

	// Field (1) 'Signature'
	dst = append(dst, s.Signature[:]...)

	return
}

// UnmarshalSSZ ssz unmarshals the SignedBeaconBlockHeader object
func (s *SignedBeaconBlockHeader) UnmarshalSSZ(buf []byte) error {
	return ssz.UnmarshalSSZ(s, buf)
}

// UnmarshalSSZTail unmarshals the SignedBeaconBlockHeader object and returns the remaining bufferº
func (s *SignedBeaconBlockHeader) UnmarshalSSZTail(buf []byte) (rest []byte, err error) {
	size := len(buf)
	fixedSize := s.fixedSize()
	if size < fixedSize {
		return nil, ssz.ErrSize
	}

	// Field (0) 'Message'
	if buf, err = ssz.UnmarshalFieldTail(&s.Message, buf); err != nil {
		return
	}

	// Field (1) 'Signature'
	buf = ssz.UnmarshalFixedBytes(s.Signature[:], buf)

	return buf, nil
}

// fixedSize returns the fixed size of the SignedBeaconBlockHeader object
func (s *SignedBeaconBlockHeader) fixedSize() int {
	return int(208)
}

// SizeSSZ returns the ssz encoded size in bytes for the SignedBeaconBlockHeader object
func (s *SignedBeaconBlockHeader) SizeSSZ() (size int) {
	size = s.fixedSize()
	return
}

// HashTreeRoot ssz hashes the SignedBeaconBlockHeader object
func (s *SignedBeaconBlockHeader) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(s)
}

// HashTreeRootWith ssz hashes the SignedBeaconBlockHeader object with a hasher
func (s *SignedBeaconBlockHeader) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'Message'
	if s.Message == nil {
		s.Message = new(BeaconBlockHeader)
	}
	if err = s.Message.HashTreeRootWith(hh); err != nil {
		return
	}

	// Field (1) 'Signature'
	hh.PutBytes(s.Signature[:])

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the SignedBeaconBlockHeader object
func (s *SignedBeaconBlockHeader) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(s)
}

// MarshalSSZ ssz marshals the ETH1Data object
func (e *ETH1Data) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(e)
}

// MarshalSSZTo ssz marshals the ETH1Data object to a target array
func (e *ETH1Data) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf

	// Field (0) 'DepositRoot'
	dst = append(dst, e.DepositRoot[:]...)

	// Field (1) 'DepositCount'
	dst = ssz.MarshalValue(dst, e.DepositCount)

	// Field (2) 'BlockHash'
	dst = append(dst, e.BlockHash[:]...)

	return
}

// UnmarshalSSZ ssz unmarshals the ETH1Data object
func (e *ETH1Data) UnmarshalSSZ(buf []byte) error {
	return ssz.UnmarshalSSZ(e, buf)
}

// UnmarshalSSZTail unmarshals the ETH1Data object and returns the remaining bufferº
func (e *ETH1Data) UnmarshalSSZTail(buf []byte) (rest []byte, err error) {
	size := len(buf)
	fixedSize := e.fixedSize()
	if size < fixedSize {
		return nil, ssz.ErrSize
	}

	// Field (0) 'DepositRoot'
	buf = ssz.UnmarshalFixedBytes(e.DepositRoot[:], buf)

	// Field (1) 'DepositCount'
	e.DepositCount, buf = ssz.UnmarshallValue[uint64](buf)

	// Field (2) 'BlockHash'
	buf = ssz.UnmarshalFixedBytes(e.BlockHash[:], buf)

	return buf, nil
}

// fixedSize returns the fixed size of the ETH1Data object
func (e *ETH1Data) fixedSize() int {
	return int(72)
}

// SizeSSZ returns the ssz encoded size in bytes for the ETH1Data object
func (e *ETH1Data) SizeSSZ() (size int) {
	size = e.fixedSize()
	return
}

// HashTreeRoot ssz hashes the ETH1Data object
func (e *ETH1Data) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(e)
}

// HashTreeRootWith ssz hashes the ETH1Data object with a hasher
func (e *ETH1Data) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'DepositRoot'
	hh.PutBytes(e.DepositRoot[:])

	// Field (1) 'DepositCount'
	hh.PutUint64(e.DepositCount)

	// Field (2) 'BlockHash'
	hh.PutBytes(e.BlockHash[:])

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the ETH1Data object
func (e *ETH1Data) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(e)
}

// MarshalSSZ ssz marshals the Validator object
func (v *Validator) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(v)
}

// MarshalSSZTo ssz marshals the Validator object to a target array
func (v *Validator) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf

	// Field (0) 'Pubkey'
	dst = append(dst, v.Pubkey[:]...)

	// Field (1) 'WithdrawalCredentials'
	dst = append(dst, v.WithdrawalCredentials[:]...)

	// Field (2) 'EffectiveBalance'
	dst = ssz.MarshalValue(dst, uint64(v.EffectiveBalance))

	// Field (3) 'Slashed'
	dst = ssz.MarshalValue(dst, v.Slashed)

	// Field (4) 'ActivationEligibilityEpoch'
	dst = ssz.MarshalValue(dst, uint64(v.ActivationEligibilityEpoch))

	// Field (5) 'ActivationEpoch'
	dst = ssz.MarshalValue(dst, uint64(v.ActivationEpoch))

	// Field (6) 'ExitEpoch'
	dst = ssz.MarshalValue(dst, uint64(v.ExitEpoch))

	// Field (7) 'WithdrawableEpoch'
	dst = ssz.MarshalValue(dst, uint64(v.WithdrawableEpoch))

	return
}

// UnmarshalSSZ ssz unmarshals the Validator object
func (v *Validator) UnmarshalSSZ(buf []byte) error {
	return ssz.UnmarshalSSZ(v, buf)
}

// UnmarshalSSZTail unmarshals the Validator object and returns the remaining bufferº
func (v *Validator) UnmarshalSSZTail(buf []byte) (rest []byte, err error) {
	size := len(buf)
	fixedSize := v.fixedSize()
	if size < fixedSize {
		return nil, ssz.ErrSize
	}

	// Field (0) 'Pubkey'
	buf = ssz.UnmarshalFixedBytes(v.Pubkey[:], buf)

	// Field (1) 'WithdrawalCredentials'
	buf = ssz.UnmarshalFixedBytes(v.WithdrawalCredentials[:], buf)

	// Field (2) 'EffectiveBalance'
	{
		var val uint64
		val, buf = ssz.UnmarshallValue[uint64](buf)
		v.EffectiveBalance = Gwei(val)
	}

	// Field (3) 'Slashed'
	if err = ssz.IsValidBool(buf); err != nil {
		return
	}
	v.Slashed, buf = ssz.UnmarshallValue[bool](buf)

	// Field (4) 'ActivationEligibilityEpoch'
	{
		var val uint64
		val, buf = ssz.UnmarshallValue[uint64](buf)
		v.ActivationEligibilityEpoch = Epoch(val)
	}

	// Field (5) 'ActivationEpoch'
	{
		var val uint64
		val, buf = ssz.UnmarshallValue[uint64](buf)
		v.ActivationEpoch = Epoch(val)
	}

	// Field (6) 'ExitEpoch'
	{
		var val uint64
		val, buf = ssz.UnmarshallValue[uint64](buf)
		v.ExitEpoch = Epoch(val)
	}

	// Field (7) 'WithdrawableEpoch'
	{
		var val uint64
		val, buf = ssz.UnmarshallValue[uint64](buf)
		v.WithdrawableEpoch = Epoch(val)
	}

	return buf, nil
}

// fixedSize returns the fixed size of the Validator object
func (v *Validator) fixedSize() int {
	return int(121)
}

// SizeSSZ returns the ssz encoded size in bytes for the Validator object
func (v *Validator) SizeSSZ() (size int) {
	size = v.fixedSize()
	return
}

// HashTreeRoot ssz hashes the Validator object
func (v *Validator) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(v)
}

// HashTreeRootWith ssz hashes the Validator object with a hasher
func (v *Validator) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'Pubkey'
	hh.PutBytes(v.Pubkey[:])

	// Field (1) 'WithdrawalCredentials'
	hh.PutBytes(v.WithdrawalCredentials[:])

	// Field (2) 'EffectiveBalance'
	hh.PutUint64(uint64(v.EffectiveBalance))

	// Field (3) 'Slashed'
	hh.PutBool(v.Slashed)

	// Field (4) 'ActivationEligibilityEpoch'
	hh.PutUint64(uint64(v.ActivationEligibilityEpoch))

	// Field (5) 'ActivationEpoch'
	hh.PutUint64(uint64(v.ActivationEpoch))

	// Field (6) 'ExitEpoch'
	hh.PutUint64(uint64(v.ExitEpoch))

	// Field (7) 'WithdrawableEpoch'
	hh.PutUint64(uint64(v.WithdrawableEpoch))

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the Validator object
func (v *Validator) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(v)
}

// MarshalSSZ ssz marshals the ProposerSlashing object
func (p *ProposerSlashing) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(p)
}

// MarshalSSZTo ssz marshals the ProposerSlashing object to a target array
func (p *ProposerSlashing) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf

	// Field (0) 'SignedHeader1'
	if p.SignedHeader1 == nil {
		p.SignedHeader1 = new(SignedBeaconBlockHeader)
	}
	if dst, err = p.SignedHeader1.MarshalSSZTo(dst); err != nil {
		return
	}

	// Field (1) 'SignedHeader2'
	if p.SignedHeader2 == nil {
		p.SignedHeader2 = new(SignedBeaconBlockHeader)
	}
	if dst, err = p.SignedHeader2.MarshalSSZTo(dst); err != nil {
		return
	}

	return
}

// UnmarshalSSZ ssz unmarshals the ProposerSlashing object
func (p *ProposerSlashing) UnmarshalSSZ(buf []byte) error {
	return ssz.UnmarshalSSZ(p, buf)
}

// UnmarshalSSZTail unmarshals the ProposerSlashing object and returns the remaining bufferº
func (p *ProposerSlashing) UnmarshalSSZTail(buf []byte) (rest []byte, err error) {
	size := len(buf)
	fixedSize := p.fixedSize()
	if size < fixedSize {
		return nil, ssz.ErrSize
	}

	// Field (0) 'SignedHeader1'
	if buf, err = ssz.UnmarshalFieldTail(&p.SignedHeader1, buf); err != nil {
		return
	}

	// Field (1) 'SignedHeader2'
	if buf, err = ssz.UnmarshalFieldTail(&p.SignedHeader2, buf); err != nil {
		return
	}

	return buf, nil
}

// fixedSize returns the fixed size of the ProposerSlashing object
func (p *ProposerSlashing) fixedSize() int {
	return int(416)
}

// SizeSSZ returns the ssz encoded size in bytes for the ProposerSlashing object
func (p *ProposerSlashing) SizeSSZ() (size int) {
	size = p.fixedSize()
	return
}

// HashTreeRoot ssz hashes the ProposerSlashing object
func (p *ProposerSlashing) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(p)
}

// HashTreeRootWith ssz hashes the ProposerSlashing object with a hasher
func (p *ProposerSlashing) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'SignedHeader1'
	if p.SignedHeader1 == nil {
		p.SignedHeader1 = new(SignedBeaconBlockHeader)
	}
	if err = p.SignedHeader1.HashTreeRootWith(hh); err != nil {
		return
	}

	// Field (1) 'SignedHeader2'
	if p.SignedHeader2 == nil {
		p.SignedHeader2 = new(SignedBeaconBlockHeader)
	}
	if err = p.SignedHeader2.HashTreeRootWith(hh); err != nil {
		return
	}

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the ProposerSlashing object
func (p *ProposerSlashing) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(p)
}

// MarshalSSZ ssz marshals the AttestationData object
func (a *AttestationData) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(a)
}

// MarshalSSZTo ssz marshals the AttestationData object to a target array
func (a *AttestationData) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf

	// Field (0) 'Slot'
	dst = ssz.MarshalValue(dst, uint64(a.Slot))

	// Field (1) 'Index'
	dst = ssz.MarshalValue(dst, a.Index)

	// Field (2) 'BeaconBlockRoot'
	dst = append(dst, a.BeaconBlockRoot[:]...)

	// Field (3) 'Source'
	if a.Source == nil {
		a.Source = new(Checkpoint)
	}
	if dst, err = a.Source.MarshalSSZTo(dst); err != nil {
		return
	}

	// Field (4) 'Target'
	if a.Target == nil {
		a.Target = new(Checkpoint)
	}
	if dst, err = a.Target.MarshalSSZTo(dst); err != nil {
		return
	}

	return
}

// UnmarshalSSZ ssz unmarshals the AttestationData object
func (a *AttestationData) UnmarshalSSZ(buf []byte) error {
	return ssz.UnmarshalSSZ(a, buf)
}

// UnmarshalSSZTail unmarshals the AttestationData object and returns the remaining bufferº
func (a *AttestationData) UnmarshalSSZTail(buf []byte) (rest []byte, err error) {
	size := len(buf)
	fixedSize := a.fixedSize()
	if size < fixedSize {
		return nil, ssz.ErrSize
	}

	// Field (0) 'Slot'
	{
		var val uint64
		val, buf = ssz.UnmarshallValue[uint64](buf)
		a.Slot = Slot(val)
	}

	// Field (1) 'Index'
	a.Index, buf = ssz.UnmarshallValue[uint64](buf)

	// Field (2) 'BeaconBlockRoot'
	buf = ssz.UnmarshalFixedBytes(a.BeaconBlockRoot[:], buf)

	// Field (3) 'Source'
	if buf, err = ssz.UnmarshalFieldTail(&a.Source, buf); err != nil {
		return
	}

	// Field (4) 'Target'
	if buf, err = ssz.UnmarshalFieldTail(&a.Target, buf); err != nil {
		return
	}

	return buf, nil
}

// fixedSize returns the fixed size of the AttestationData object
func (a *AttestationData) fixedSize() int {
	return int(128)
}

// SizeSSZ returns the ssz encoded size in bytes for the AttestationData object
func (a *AttestationData) SizeSSZ() (size int) {
	size = a.fixedSize()
	return
}

// HashTreeRoot ssz hashes the AttestationData object
func (a *AttestationData) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(a)
}

// HashTreeRootWith ssz hashes the AttestationData object with a hasher
func (a *AttestationData) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'Slot'
	hh.PutUint64(uint64(a.Slot))

	// Field (1) 'Index'
	hh.PutUint64(a.Index)

	// Field (2) 'BeaconBlockRoot'
	hh.PutBytes(a.BeaconBlockRoot[:])

	// Field (3) 'Source'
	if a.Source == nil {
		a.Source = new(Checkpoint)
	}
	if err = a.Source.HashTreeRootWith(hh); err != nil {
		return
	}

	// Field (4) 'Target'
	if a.Target == nil {
		a.Target = new(Checkpoint)
	}
	if err = a.Target.HashTreeRootWith(hh); err != nil {
		return
	}

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the AttestationData object
func (a *AttestationData) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(a)
}

// MarshalSSZ ssz marshals the IndexedAttestation object
func (i *IndexedAttestation) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(i)
}

// MarshalSSZTo ssz marshals the IndexedAttestation object to a target array
func (i *IndexedAttestation) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := i.fixedSize()

	// Offset (0) 'AttestingIndices'
	dst = ssz.WriteOffset(dst, offset)

	// Field (1) 'Data'
	if i.Data == nil {
		i.Data = new(AttestationData)
	}
	if dst, err = i.Data.MarshalSSZTo(dst); err != nil {
		return
	}

	// Field (2) 'Signature'
	dst = append(dst, i.Signature[:]...)

	// Field (0) 'AttestingIndices'
	if size := uint64(len(i.AttestingIndices)); size > 2048 {
		err = ssz.ErrListTooBigFn("IndexedAttestation.AttestingIndices", size, 2048)
		return
	}
	for ii := 0; ii < len(i.AttestingIndices); ii++ {
		dst = ssz.MarshalValue(dst, i.AttestingIndices[ii])
	}

	return
}

// UnmarshalSSZ ssz unmarshals the IndexedAttestation object
func (i *IndexedAttestation) UnmarshalSSZ(buf []byte) error {
	return ssz.UnmarshalSSZ(i, buf)
}

// UnmarshalSSZTail unmarshals the IndexedAttestation object and returns the remaining bufferº
func (i *IndexedAttestation) UnmarshalSSZTail(buf []byte) (rest []byte, err error) {
	size := len(buf)
	fixedSize := i.fixedSize()
	if size < fixedSize {
		return nil, ssz.ErrSize
	}

	tail := buf
	var o0 uint64
	marker := ssz.NewOffsetMarker(uint64(size), uint64(fixedSize))

	// Offset (0) 'AttestingIndices'
	if o0, buf, err = marker.ReadOffset(buf); err != nil {
		return nil, err
	}

	// Field (1) 'Data'
	if buf, err = ssz.UnmarshalFieldTail(&i.Data, buf); err != nil {
		return
	}

	// Field (2) 'Signature'
	buf = ssz.UnmarshalFixedBytes(i.Signature[:], buf)

	// Field (0) 'AttestingIndices'
	if err = ssz.UnmarshalSliceWithIndexCallback(&i.AttestingIndices, tail[o0:], 8, 2048, func(ii uint64, buf []byte) (err error) {
		i.AttestingIndices[ii], buf = ssz.UnmarshallValue[uint64](buf)
		return nil
	}); err != nil {
		return nil, err
	}

	return
}

// fixedSize returns the fixed size of the IndexedAttestation object
func (i *IndexedAttestation) fixedSize() int {
	return int(228)
}

// SizeSSZ returns the ssz encoded size in bytes for the IndexedAttestation object
func (i *IndexedAttestation) SizeSSZ() (size int) {
	size = i.fixedSize()

	// Field (0) 'AttestingIndices'
	size += len(i.AttestingIndices) * 8

	return
}

// HashTreeRoot ssz hashes the IndexedAttestation object
func (i *IndexedAttestation) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(i)
}

// HashTreeRootWith ssz hashes the IndexedAttestation object with a hasher
func (i *IndexedAttestation) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'AttestingIndices'
	{
		if size := uint64(len(i.AttestingIndices)); size > 2048 {
			err = ssz.ErrListTooBigFn("IndexedAttestation.AttestingIndices", size, 2048)
			return
		}
		subIndx := hh.Index()
		for _, i := range i.AttestingIndices {
			hh.AppendUint64(i)
		}
		hh.FillUpTo32()
		numItems := uint64(len(i.AttestingIndices))
		hh.MerkleizeWithMixin(subIndx, numItems, ssz.CalculateLimit(2048, numItems, 8))
	}

	// Field (1) 'Data'
	if i.Data == nil {
		i.Data = new(AttestationData)
	}
	if err = i.Data.HashTreeRootWith(hh); err != nil {
		return
	}

	// Field (2) 'Signature'
	hh.PutBytes(i.Signature[:])

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the IndexedAttestation object
func (i *IndexedAttestation) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(i)
}

// MarshalSSZ ssz marshals the AttesterSlashing object
func (a *AttesterSlashing) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(a)
}

// MarshalSSZTo ssz marshals the AttesterSlashing object to a target array
func (a *AttesterSlashing) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := a.fixedSize()

	// Offset (0) 'Attestation1'
	dst = ssz.WriteOffset(dst, offset)
	if a.Attestation1 == nil {
		a.Attestation1 = new(IndexedAttestation)
	}
	offset += a.Attestation1.SizeSSZ()

	// Offset (1) 'Attestation2'
	dst = ssz.WriteOffset(dst, offset)

	// Field (0) 'Attestation1'
	if dst, err = a.Attestation1.MarshalSSZTo(dst); err != nil {
		return
	}

	// Field (1) 'Attestation2'
	if dst, err = a.Attestation2.MarshalSSZTo(dst); err != nil {
		return
	}

	return
}

// UnmarshalSSZ ssz unmarshals the AttesterSlashing object
func (a *AttesterSlashing) UnmarshalSSZ(buf []byte) error {
	return ssz.UnmarshalSSZ(a, buf)
}

// UnmarshalSSZTail unmarshals the AttesterSlashing object and returns the remaining bufferº
func (a *AttesterSlashing) UnmarshalSSZTail(buf []byte) (rest []byte, err error) {
	size := len(buf)
	fixedSize := a.fixedSize()
	if size < fixedSize {
		return nil, ssz.ErrSize
	}

	tail := buf
	var o0, o1 uint64
	marker := ssz.NewOffsetMarker(uint64(size), uint64(fixedSize))

	// Offset (0) 'Attestation1'
	if o0, buf, err = marker.ReadOffset(buf); err != nil {
		return nil, err
	}

	// Offset (1) 'Attestation2'
	if o1, _, err = marker.ReadOffset(buf); err != nil {
		return nil, err
	}

	// Field (0) 'Attestation1'
	if err = ssz.UnmarshalField(&a.Attestation1, tail[o0:o1]); err != nil {
		return
	}

	// Field (1) 'Attestation2'
	if err = ssz.UnmarshalField(&a.Attestation2, tail[o1:]); err != nil {
		return
	}

	return
}

// fixedSize returns the fixed size of the AttesterSlashing object
func (a *AttesterSlashing) fixedSize() int {
	return int(8)
}

// SizeSSZ returns the ssz encoded size in bytes for the AttesterSlashing object
func (a *AttesterSlashing) SizeSSZ() (size int) {
	size = a.fixedSize()

	// Field (0) 'Attestation1'
	if a.Attestation1 == nil {
		a.Attestation1 = new(IndexedAttestation)
	}
	size += a.Attestation1.SizeSSZ()

	// Field (1) 'Attestation2'
	if a.Attestation2 == nil {
		a.Attestation2 = new(IndexedAttestation)
	}
	size += a.Attestation2.SizeSSZ()

	return
}

// HashTreeRoot ssz hashes the AttesterSlashing object
func (a *AttesterSlashing) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(a)
}

// HashTreeRootWith ssz hashes the AttesterSlashing object with a hasher
func (a *AttesterSlashing) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'Attestation1'
	if err = a.Attestation1.HashTreeRootWith(hh); err != nil {
		return
	}

	// Field (1) 'Attestation2'
	if err = a.Attestation2.HashTreeRootWith(hh); err != nil {
		return
	}

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the AttesterSlashing object
func (a *AttesterSlashing) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(a)
}

// MarshalSSZ ssz marshals the Attestation object
func (a *Attestation) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(a)
}

// MarshalSSZTo ssz marshals the Attestation object to a target array
func (a *Attestation) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := a.fixedSize()

	// Offset (0) 'AggregationBits'
	dst = ssz.WriteOffset(dst, offset)

	// Field (1) 'Data'
	if a.Data == nil {
		a.Data = new(AttestationData)
	}
	if dst, err = a.Data.MarshalSSZTo(dst); err != nil {
		return
	}

	// Field (2) 'Signature'
	dst = append(dst, a.Signature[:]...)

	// Field (0) 'AggregationBits'
	if size := ssz.BitlistLen(a.AggregationBits); size > 2048 {
		err = ssz.ErrBytesLengthFn("Attestation.AggregationBits", size, 2048)
		return
	}
	dst = append(dst, a.AggregationBits...)

	return
}

// UnmarshalSSZ ssz unmarshals the Attestation object
func (a *Attestation) UnmarshalSSZ(buf []byte) error {
	return ssz.UnmarshalSSZ(a, buf)
}

// UnmarshalSSZTail unmarshals the Attestation object and returns the remaining bufferº
func (a *Attestation) UnmarshalSSZTail(buf []byte) (rest []byte, err error) {
	size := len(buf)
	fixedSize := a.fixedSize()
	if size < fixedSize {
		return nil, ssz.ErrSize
	}

	tail := buf
	var o0 uint64
	marker := ssz.NewOffsetMarker(uint64(size), uint64(fixedSize))

	// Offset (0) 'AggregationBits'
	if o0, buf, err = marker.ReadOffset(buf); err != nil {
		return nil, err
	}

	// Field (1) 'Data'
	if buf, err = ssz.UnmarshalFieldTail(&a.Data, buf); err != nil {
		return
	}

	// Field (2) 'Signature'
	buf = ssz.UnmarshalFixedBytes(a.Signature[:], buf)

	// Field (0) 'AggregationBits'
	if a.AggregationBits, err = ssz.UnmarshalBitList(a.AggregationBits, tail[o0:], 2048); err != nil {
		return nil, err
	}

	return
}

// fixedSize returns the fixed size of the Attestation object
func (a *Attestation) fixedSize() int {
	return int(228)
}

// SizeSSZ returns the ssz encoded size in bytes for the Attestation object
func (a *Attestation) SizeSSZ() (size int) {
	size = a.fixedSize()

	// Field (0) 'AggregationBits'
	size += len(a.AggregationBits)

	return
}

// HashTreeRoot ssz hashes the Attestation object
func (a *Attestation) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(a)
}

// HashTreeRootWith ssz hashes the Attestation object with a hasher
func (a *Attestation) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'AggregationBits'
	if len(a.AggregationBits) == 0 {
		err = ssz.ErrEmptyBitlist
		return
	}
	hh.PutBitlist(a.AggregationBits, 2048)

	// Field (1) 'Data'
	if a.Data == nil {
		a.Data = new(AttestationData)
	}
	if err = a.Data.HashTreeRootWith(hh); err != nil {
		return
	}

	// Field (2) 'Signature'
	hh.PutBytes(a.Signature[:])

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the Attestation object
func (a *Attestation) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(a)
}

// MarshalSSZ ssz marshals the DepositData object
func (d *DepositData) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(d)
}

// MarshalSSZTo ssz marshals the DepositData object to a target array
func (d *DepositData) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf

	// Field (0) 'Pubkey'
	dst = append(dst, d.Pubkey[:]...)

	// Field (1) 'WithdrawalCredentials'
	dst = append(dst, d.WithdrawalCredentials[:]...)

	// Field (2) 'Amount'
	dst = ssz.MarshalValue(dst, uint64(d.Amount))

	// Field (3) 'Signature'
	dst = append(dst, d.Signature[:]...)

	return
}

// UnmarshalSSZ ssz unmarshals the DepositData object
func (d *DepositData) UnmarshalSSZ(buf []byte) error {
	return ssz.UnmarshalSSZ(d, buf)
}

// UnmarshalSSZTail unmarshals the DepositData object and returns the remaining bufferº
func (d *DepositData) UnmarshalSSZTail(buf []byte) (rest []byte, err error) {
	size := len(buf)
	fixedSize := d.fixedSize()
	if size < fixedSize {
		return nil, ssz.ErrSize
	}

	// Field (0) 'Pubkey'
	buf = ssz.UnmarshalFixedBytes(d.Pubkey[:], buf)

	// Field (1) 'WithdrawalCredentials'
	buf = ssz.UnmarshalFixedBytes(d.WithdrawalCredentials[:], buf)

	// Field (2) 'Amount'
	{
		var val uint64
		val, buf = ssz.UnmarshallValue[uint64](buf)
		d.Amount = Gwei(val)
	}

	// Field (3) 'Signature'
	buf = ssz.UnmarshalFixedBytes(d.Signature[:], buf)

	return buf, nil
}

// fixedSize returns the fixed size of the DepositData object
func (d *DepositData) fixedSize() int {
	return int(184)
}

// SizeSSZ returns the ssz encoded size in bytes for the DepositData object
func (d *DepositData) SizeSSZ() (size int) {
	size = d.fixedSize()
	return
}

// HashTreeRoot ssz hashes the DepositData object
func (d *DepositData) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(d)
}

// HashTreeRootWith ssz hashes the DepositData object with a hasher
func (d *DepositData) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'Pubkey'
	hh.PutBytes(d.Pubkey[:])

	// Field (1) 'WithdrawalCredentials'
	hh.PutBytes(d.WithdrawalCredentials[:])

	// Field (2) 'Amount'
	hh.PutUint64(uint64(d.Amount))

	// Field (3) 'Signature'
	hh.PutBytes(d.Signature[:])

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the DepositData object
func (d *DepositData) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(d)
}

// MarshalSSZ ssz marshals the Deposit object
func (d *Deposit) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(d)
}

// MarshalSSZTo ssz marshals the Deposit object to a target array
func (d *Deposit) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf

	// Field (0) 'Proof'
	if size := uint64(len(d.Proof)); size != 33 {
		err = ssz.ErrVectorLengthFn("Deposit.Proof", size, 33)
		return
	}
	for ii := uint64(0); ii < 33; ii++ {
		if size := uint64(len(d.Proof[ii])); size != 32 {
			err = ssz.ErrBytesLengthFn("Deposit.Proof[ii]", size, 32)
			return
		}
		dst = append(dst, d.Proof[ii]...)
	}

	// Field (1) 'Data'
	if d.Data == nil {
		d.Data = new(DepositData)
	}
	if dst, err = d.Data.MarshalSSZTo(dst); err != nil {
		return
	}

	return
}

// UnmarshalSSZ ssz unmarshals the Deposit object
func (d *Deposit) UnmarshalSSZ(buf []byte) error {
	return ssz.UnmarshalSSZ(d, buf)
}

// UnmarshalSSZTail unmarshals the Deposit object and returns the remaining bufferº
func (d *Deposit) UnmarshalSSZTail(buf []byte) (rest []byte, err error) {
	size := len(buf)
	fixedSize := d.fixedSize()
	if size < fixedSize {
		return nil, ssz.ErrSize
	}

	// Field (0) 'Proof'
	d.Proof = make([][]byte, 33)
	for ii := uint64(0); ii < 33; ii++ {
		d.Proof[ii], buf = ssz.UnmarshalBytes(d.Proof[ii], buf, 32)
	}

	// Field (1) 'Data'
	if buf, err = ssz.UnmarshalFieldTail(&d.Data, buf); err != nil {
		return
	}

	return buf, nil
}

// fixedSize returns the fixed size of the Deposit object
func (d *Deposit) fixedSize() int {
	return int(1240)
}

// SizeSSZ returns the ssz encoded size in bytes for the Deposit object
func (d *Deposit) SizeSSZ() (size int) {
	size = d.fixedSize()
	return
}

// HashTreeRoot ssz hashes the Deposit object
func (d *Deposit) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(d)
}

// HashTreeRootWith ssz hashes the Deposit object with a hasher
func (d *Deposit) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'Proof'
	{
		if size := uint64(len(d.Proof)); size != 33 {
			err = ssz.ErrVectorLengthFn("Deposit.Proof", size, 33)
			return
		}
		subIndx := hh.Index()
		for _, i := range d.Proof {
			if len(i) != 32 {
				err = ssz.ErrBytesLength
				return
			}
			hh.Append(i)
		}
		hh.Merkleize(subIndx)
	}

	// Field (1) 'Data'
	if d.Data == nil {
		d.Data = new(DepositData)
	}
	if err = d.Data.HashTreeRootWith(hh); err != nil {
		return
	}

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the Deposit object
func (d *Deposit) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(d)
}

// MarshalSSZ ssz marshals the VoluntaryExit object
func (v *VoluntaryExit) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(v)
}

// MarshalSSZTo ssz marshals the VoluntaryExit object to a target array
func (v *VoluntaryExit) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf

	// Field (0) 'Epoch'
	dst = ssz.MarshalValue(dst, uint64(v.Epoch))

	// Field (1) 'ValidatorIndex'
	dst = ssz.MarshalValue(dst, uint64(v.ValidatorIndex))

	return
}

// UnmarshalSSZ ssz unmarshals the VoluntaryExit object
func (v *VoluntaryExit) UnmarshalSSZ(buf []byte) error {
	return ssz.UnmarshalSSZ(v, buf)
}

// UnmarshalSSZTail unmarshals the VoluntaryExit object and returns the remaining bufferº
func (v *VoluntaryExit) UnmarshalSSZTail(buf []byte) (rest []byte, err error) {
	size := len(buf)
	fixedSize := v.fixedSize()
	if size < fixedSize {
		return nil, ssz.ErrSize
	}

	// Field (0) 'Epoch'
	{
		var val uint64
		val, buf = ssz.UnmarshallValue[uint64](buf)
		v.Epoch = Epoch(val)
	}

	// Field (1) 'ValidatorIndex'
	{
		var val uint64
		val, buf = ssz.UnmarshallValue[uint64](buf)
		v.ValidatorIndex = ValidatorIndex(val)
	}

	return buf, nil
}

// fixedSize returns the fixed size of the VoluntaryExit object
func (v *VoluntaryExit) fixedSize() int {
	return int(16)
}

// SizeSSZ returns the ssz encoded size in bytes for the VoluntaryExit object
func (v *VoluntaryExit) SizeSSZ() (size int) {
	size = v.fixedSize()
	return
}

// HashTreeRoot ssz hashes the VoluntaryExit object
func (v *VoluntaryExit) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(v)
}

// HashTreeRootWith ssz hashes the VoluntaryExit object with a hasher
func (v *VoluntaryExit) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'Epoch'
	hh.PutUint64(uint64(v.Epoch))

	// Field (1) 'ValidatorIndex'
	hh.PutUint64(uint64(v.ValidatorIndex))

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the VoluntaryExit object
func (v *VoluntaryExit) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(v)
}

// MarshalSSZ ssz marshals the SignedVoluntaryExit object
func (s *SignedVoluntaryExit) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(s)
}

// MarshalSSZTo ssz marshals the SignedVoluntaryExit object to a target array
func (s *SignedVoluntaryExit) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf

	// Field (0) 'Message'
	if s.Message == nil {
		s.Message = new(VoluntaryExit)
	}
	if dst, err = s.Message.MarshalSSZTo(dst); err != nil {
		return
	}

	// Field (1) 'Signature'
	dst = append(dst, s.Signature[:]...)

	return
}

// UnmarshalSSZ ssz unmarshals the SignedVoluntaryExit object
func (s *SignedVoluntaryExit) UnmarshalSSZ(buf []byte) error {
	return ssz.UnmarshalSSZ(s, buf)
}

// UnmarshalSSZTail unmarshals the SignedVoluntaryExit object and returns the remaining bufferº
func (s *SignedVoluntaryExit) UnmarshalSSZTail(buf []byte) (rest []byte, err error) {
	size := len(buf)
	fixedSize := s.fixedSize()
	if size < fixedSize {
		return nil, ssz.ErrSize
	}

	// Field (0) 'Message'
	if buf, err = ssz.UnmarshalFieldTail(&s.Message, buf); err != nil {
		return
	}

	// Field (1) 'Signature'
	buf = ssz.UnmarshalFixedBytes(s.Signature[:], buf)

	return buf, nil
}

// fixedSize returns the fixed size of the SignedVoluntaryExit object
func (s *SignedVoluntaryExit) fixedSize() int {
	return int(112)
}

// SizeSSZ returns the ssz encoded size in bytes for the SignedVoluntaryExit object
func (s *SignedVoluntaryExit) SizeSSZ() (size int) {
	size = s.fixedSize()
	return
}

// HashTreeRoot ssz hashes the SignedVoluntaryExit object
func (s *SignedVoluntaryExit) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(s)
}

// HashTreeRootWith ssz hashes the SignedVoluntaryExit object with a hasher
func (s *SignedVoluntaryExit) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'Message'
	if s.Message == nil {
		s.Message = new(VoluntaryExit)
	}
	if err = s.Message.HashTreeRootWith(hh); err != nil {
		return
	}

	// Field (1) 'Signature'
	hh.PutBytes(s.Signature[:])

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the SignedVoluntaryExit object
func (s *SignedVoluntaryExit) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(s)
}

// MarshalSSZ ssz marshals the SyncAggregate object
func (s *SyncAggregate) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(s)
}

// MarshalSSZTo ssz marshals the SyncAggregate object to a target array
func (s *SyncAggregate) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf

	// Field (0) 'SyncCommitteeBits'
	if size := uint64(len(s.SyncCommitteeBits)); size != syncCommitteeBitsSize {
		err = ssz.ErrBytesLengthFn("SyncAggregate.SyncCommitteeBits", size, syncCommitteeBitsSize)
		return
	}
	dst = append(dst, s.SyncCommitteeBits...)

	// Field (1) 'SyncCommitteeSignature'
	dst = append(dst, s.SyncCommitteeSignature[:]...)

	return
}

// UnmarshalSSZ ssz unmarshals the SyncAggregate object
func (s *SyncAggregate) UnmarshalSSZ(buf []byte) error {
	return ssz.UnmarshalSSZ(s, buf)
}

// UnmarshalSSZTail unmarshals the SyncAggregate object and returns the remaining bufferº
func (s *SyncAggregate) UnmarshalSSZTail(buf []byte) (rest []byte, err error) {
	size := len(buf)
	fixedSize := s.fixedSize()
	if size < fixedSize {
		return nil, ssz.ErrSize
	}

	// Field (0) 'SyncCommitteeBits'
	s.SyncCommitteeBits, buf = ssz.UnmarshalBytes(s.SyncCommitteeBits, buf, syncCommitteeBitsSize)

	// Field (1) 'SyncCommitteeSignature'
	buf = ssz.UnmarshalFixedBytes(s.SyncCommitteeSignature[:], buf)

	return buf, nil
}

// fixedSize returns the fixed size of the SyncAggregate object
func (s *SyncAggregate) fixedSize() int {
	return int((96 + syncCommitteeBitsSize))
}

// SizeSSZ returns the ssz encoded size in bytes for the SyncAggregate object
func (s *SyncAggregate) SizeSSZ() (size int) {
	size = s.fixedSize()
	return
}

// HashTreeRoot ssz hashes the SyncAggregate object
func (s *SyncAggregate) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(s)
}

// HashTreeRootWith ssz hashes the SyncAggregate object with a hasher
func (s *SyncAggregate) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'SyncCommitteeBits'
	if size := uint64(len(s.SyncCommitteeBits)); size != syncCommitteeBitsSize {
		err = ssz.ErrBytesLengthFn("SyncAggregate.SyncCommitteeBits", size, syncCommitteeBitsSize)
		return
	}
	hh.PutBytes(s.SyncCommitteeBits)

	// Field (1) 'SyncCommitteeSignature'
	hh.PutBytes(s.SyncCommitteeSignature[:])

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the SyncAggregate object
func (s *SyncAggregate) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(s)
}

// MarshalSSZ ssz marshals the SyncCommittee object
func (s *SyncCommittee) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(s)
}

// MarshalSSZTo ssz marshals the SyncCommittee object to a target array
func (s *SyncCommittee) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf

	// Field (0) 'Pubkeys'
	if size := uint64(len(s.Pubkeys)); size != syncCommitteeSize {
		err = ssz.ErrVectorLengthFn("SyncCommittee.Pubkeys", size, syncCommitteeSize)
		return
	}
	for ii := uint64(0); ii < syncCommitteeSize; ii++ {
		if size := uint64(len(s.Pubkeys[ii])); size != 48 {
			err = ssz.ErrBytesLengthFn("SyncCommittee.Pubkeys[ii]", size, 48)
			return
		}
		dst = append(dst, s.Pubkeys[ii]...)
	}

	// Field (1) 'AggregatePubkey'
	dst = append(dst, s.AggregatePubkey[:]...)

	return
}

// UnmarshalSSZ ssz unmarshals the SyncCommittee object
func (s *SyncCommittee) UnmarshalSSZ(buf []byte) error {
	return ssz.UnmarshalSSZ(s, buf)
}

// UnmarshalSSZTail unmarshals the SyncCommittee object and returns the remaining bufferº
func (s *SyncCommittee) UnmarshalSSZTail(buf []byte) (rest []byte, err error) {
	size := len(buf)
	fixedSize := s.fixedSize()
	if size < fixedSize {
		return nil, ssz.ErrSize
	}

	// Field (0) 'Pubkeys'
	s.Pubkeys = make([][]byte, syncCommitteeSize)
	for ii := uint64(0); ii < syncCommitteeSize; ii++ {
		s.Pubkeys[ii], buf = ssz.UnmarshalBytes(s.Pubkeys[ii], buf, 48)
	}

	// Field (1) 'AggregatePubkey'
	buf = ssz.UnmarshalFixedBytes(s.AggregatePubkey[:], buf)

	return buf, nil
}

// fixedSize returns the fixed size of the SyncCommittee object
func (s *SyncCommittee) fixedSize() int {
	return int((48 + (syncCommitteeSize * 48)))
}

// SizeSSZ returns the ssz encoded size in bytes for the SyncCommittee object
func (s *SyncCommittee) SizeSSZ() (size int) {
	size = s.fixedSize()
	return
}

// HashTreeRoot ssz hashes the SyncCommittee object
func (s *SyncCommittee) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(s)
}

// HashTreeRootWith ssz hashes the SyncCommittee object with a hasher
func (s *SyncCommittee) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'Pubkeys'
	{
		if size := uint64(len(s.Pubkeys)); size != syncCommitteeSize {
			err = ssz.ErrVectorLengthFn("SyncCommittee.Pubkeys", size, syncCommitteeSize)
			return
		}
		subIndx := hh.Index()
		for _, i := range s.Pubkeys {
			if len(i) != 48 {
				err = ssz.ErrBytesLength
				return
			}
			hh.PutBytes(i)
		}
		hh.Merkleize(subIndx)
	}

	// Field (1) 'AggregatePubkey'
	hh.PutBytes(s.AggregatePubkey[:])

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the SyncCommittee object
func (s *SyncCommittee) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(s)
}

// MarshalSSZ ssz marshals the Withdrawal object
func (w *Withdrawal) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(w)
}

// MarshalSSZTo ssz marshals the Withdrawal object to a target array
func (w *Withdrawal) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf

	// Field (0) 'Index'
	dst = ssz.MarshalValue(dst, uint64(w.Index))

	// Field (1) 'ValidatorIndex'
	dst = ssz.MarshalValue(dst, uint64(w.ValidatorIndex))

	// Field (2) 'Address'
	dst = append(dst, w.Address[:]...)

	// Field (3) 'Amount'
	dst = ssz.MarshalValue(dst, uint64(w.Amount))

	return
}

// UnmarshalSSZ ssz unmarshals the Withdrawal object
func (w *Withdrawal) UnmarshalSSZ(buf []byte) error {
	return ssz.UnmarshalSSZ(w, buf)
}

// UnmarshalSSZTail unmarshals the Withdrawal object and returns the remaining bufferº
func (w *Withdrawal) UnmarshalSSZTail(buf []byte) (rest []byte, err error) {
	size := len(buf)
	fixedSize := w.fixedSize()
	if size < fixedSize {
		return nil, ssz.ErrSize
	}

	// Field (0) 'Index'
	{
		var val uint64
		val, buf = ssz.UnmarshallValue[uint64](buf)
		w.Index = WithdrawalIndex(val)
	}

	// Field (1) 'ValidatorIndex'
	{
		var val uint64
		val, buf = ssz.UnmarshallValue[uint64](buf)
		w.ValidatorIndex = ValidatorIndex(val)
	}

	// Field (2) 'Address'
	buf = ssz.UnmarshalFixedBytes(w.Address[:], buf)

	// Field (3) 'Amount'
	{
		var val uint64
		val, buf = ssz.UnmarshallValue[uint64](buf)
		w.Amount = Gwei(val)
	}

	return buf, nil
}

// fixedSize returns the fixed size of the Withdrawal object
func (w *Withdrawal) fixedSize() int {
	return int(44)
}

// SizeSSZ returns the ssz encoded size in bytes for the Withdrawal object
func (w *Withdrawal) SizeSSZ() (size int) {
	size = w.fixedSize()
	return
}

// HashTreeRoot ssz hashes the Withdrawal object
func (w *Withdrawal) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(w)
}

// HashTreeRootWith ssz hashes the Withdrawal object with a hasher
func (w *Withdrawal) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'Index'
	hh.PutUint64(uint64(w.Index))

	// Field (1) 'ValidatorIndex'
	hh.PutUint64(uint64(w.ValidatorIndex))

	// Field (2) 'Address'
	hh.PutBytes(w.Address[:])

	// Field (3) 'Amount'
	hh.PutUint64(uint64(w.Amount))

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the Withdrawal object
func (w *Withdrawal) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(w)
}

// MarshalSSZ ssz marshals the BLSToExecutionChange object
func (b *BLSToExecutionChange) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(b)
}

// MarshalSSZTo ssz marshals the BLSToExecutionChange object to a target array
func (b *BLSToExecutionChange) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf

	// Field (0) 'ValidatorIndex'
	dst = ssz.MarshalValue(dst, uint64(b.ValidatorIndex))

	// Field (1) 'FromBLSPubkey'
	dst = append(dst, b.FromBLSPubkey[:]...)

	// Field (2) 'ToExecutionAddress'
	dst = append(dst, b.ToExecutionAddress[:]...)

	return
}

// UnmarshalSSZ ssz unmarshals the BLSToExecutionChange object
func (b *BLSToExecutionChange) UnmarshalSSZ(buf []byte) error {
	return ssz.UnmarshalSSZ(b, buf)
}

// UnmarshalSSZTail unmarshals the BLSToExecutionChange object and returns the remaining bufferº
func (b *BLSToExecutionChange) UnmarshalSSZTail(buf []byte) (rest []byte, err error) {
	size := len(buf)
	fixedSize := b.fixedSize()
	if size < fixedSize {
		return nil, ssz.ErrSize
	}

	// Field (0) 'ValidatorIndex'
	{
		var val uint64
		val, buf = ssz.UnmarshallValue[uint64](buf)
		b.ValidatorIndex = ValidatorIndex(val)
	}

	// Field (1) 'FromBLSPubkey'
	buf = ssz.UnmarshalFixedBytes(b.FromBLSPubkey[:], buf)

	// Field (2) 'ToExecutionAddress'
	buf = ssz.UnmarshalFixedBytes(b.ToExecutionAddress[:], buf)

	return buf, nil
}

// fixedSize returns the fixed size of the BLSToExecutionChange object
func (b *BLSToExecutionChange) fixedSize() int {
	return int(76)
}

// SizeSSZ returns the ssz encoded size in bytes for the BLSToExecutionChange object
func (b *BLSToExecutionChange) SizeSSZ() (size int) {
	size = b.fixedSize()
	return
}

// HashTreeRoot ssz hashes the BLSToExecutionChange object
func (b *BLSToExecutionChange) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(b)
}

// HashTreeRootWith ssz hashes the BLSToExecutionChange object with a hasher
func (b *BLSToExecutionChange) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'ValidatorIndex'
	hh.PutUint64(uint64(b.ValidatorIndex))

	// Field (1) 'FromBLSPubkey'
	hh.PutBytes(b.FromBLSPubkey[:])

	// Field (2) 'ToExecutionAddress'
	hh.PutBytes(b.ToExecutionAddress[:])

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the BLSToExecutionChange object
func (b *BLSToExecutionChange) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(b)
}

// MarshalSSZ ssz marshals the SignedBLSToExecutionChange object
func (s *SignedBLSToExecutionChange) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(s)
}

// MarshalSSZTo ssz marshals the SignedBLSToExecutionChange object to a target array
func (s *SignedBLSToExecutionChange) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf

	// Field (0) 'Message'
	if s.Message == nil {
		s.Message = new(BLSToExecutionChange)
	}
	if dst, err = s.Message.MarshalSSZTo(dst); err != nil {
		return
	}

	// Field (1) 'Signature'
	dst = append(dst, s.Signature[:]...)

	return
}

// UnmarshalSSZ ssz unmarshals the SignedBLSToExecutionChange object
func (s *SignedBLSToExecutionChange) UnmarshalSSZ(buf []byte) error {
	return ssz.UnmarshalSSZ(s, buf)
}

// UnmarshalSSZTail unmarshals the SignedBLSToExecutionChange object and returns the remaining bufferº
func (s *SignedBLSToExecutionChange) UnmarshalSSZTail(buf []byte) (rest []byte, err error) {
	size := len(buf)
	fixedSize := s.fixedSize()
	if size < fixedSize {
		return nil, ssz.ErrSize
	}

	// Field (0) 'Message'
	if buf, err = ssz.UnmarshalFieldTail(&s.Message, buf); err != nil {
		return
	}

	// Field (1) 'Signature'
	buf = ssz.UnmarshalFixedBytes(s.Signature[:], buf)

	return buf, nil
}

// fixedSize returns the fixed size of the SignedBLSToExecutionChange object
func (s *SignedBLSToExecutionChange) fixedSize() int {
	return int(172)
}

// SizeSSZ returns the ssz encoded size in bytes for the SignedBLSToExecutionChange object
func (s *SignedBLSToExecutionChange) SizeSSZ() (size int) {
	size = s.fixedSize()
	return
}

// HashTreeRoot ssz hashes the SignedBLSToExecutionChange object
func (s *SignedBLSToExecutionChange) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(s)
}

// HashTreeRootWith ssz hashes the SignedBLSToExecutionChange object with a hasher
func (s *SignedBLSToExecutionChange) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'Message'
	if s.Message == nil {
		s.Message = new(BLSToExecutionChange)
	}
	if err = s.Message.HashTreeRootWith(hh); err != nil {
		return
	}

	// Field (1) 'Signature'
	hh.PutBytes(s.Signature[:])

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the SignedBLSToExecutionChange object
func (s *SignedBLSToExecutionChange) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(s)
}

// MarshalSSZ ssz marshals the HistoricalSummary object
func (h *HistoricalSummary) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(h)
}

// MarshalSSZTo ssz marshals the HistoricalSummary object to a target array
func (h *HistoricalSummary) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf

	// Field (0) 'BlockSummaryRoot'
	dst = append(dst, h.BlockSummaryRoot[:]...)

	// Field (1) 'StateSummaryRoot'
	dst = append(dst, h.StateSummaryRoot[:]...)

	return
}

// UnmarshalSSZ ssz unmarshals the HistoricalSummary object
func (h *HistoricalSummary) UnmarshalSSZ(buf []byte) error {
	return ssz.UnmarshalSSZ(h, buf)
}

// UnmarshalSSZTail unmarshals the HistoricalSummary object and returns the remaining bufferº
func (h *HistoricalSummary) UnmarshalSSZTail(buf []byte) (rest []byte, err error) {
	size := len(buf)
	fixedSize := h.fixedSize()
	if size < fixedSize {
		return nil, ssz.ErrSize
	}

	// Field (0) 'BlockSummaryRoot'
	buf = ssz.UnmarshalFixedBytes(h.BlockSummaryRoot[:], buf)

	// Field (1) 'StateSummaryRoot'
	buf = ssz.UnmarshalFixedBytes(h.StateSummaryRoot[:], buf)

	return buf, nil
}

// fixedSize returns the fixed size of the HistoricalSummary object
func (h *HistoricalSummary) fixedSize() int {
	return int(64)
}

// SizeSSZ returns the ssz encoded size in bytes for the HistoricalSummary object
func (h *HistoricalSummary) SizeSSZ() (size int) {
	size = h.fixedSize()
	return
}

// HashTreeRoot ssz hashes the HistoricalSummary object
func (h *HistoricalSummary) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(h)
}

// HashTreeRootWith ssz hashes the HistoricalSummary object with a hasher
func (h *HistoricalSummary) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'BlockSummaryRoot'
	hh.PutBytes(h.BlockSummaryRoot[:])

	// Field (1) 'StateSummaryRoot'
	hh.PutBytes(h.StateSummaryRoot[:])

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the HistoricalSummary object
func (h *HistoricalSummary) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(h)
}

// MarshalSSZ ssz marshals the ExecutionPayload object
func (e *ExecutionPayload) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(e)
}

// MarshalSSZTo ssz marshals the ExecutionPayload object to a target array
func (e *ExecutionPayload) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := e.fixedSize()

	// Field (0) 'ParentHash'
	dst = append(dst, e.ParentHash[:]...)

	// Field (1) 'FeeRecipient'
	dst = append(dst, e.FeeRecipient[:]...)

	// Field (2) 'StateRoot'
	dst = append(dst, e.StateRoot[:]...)

	// Field (3) 'ReceiptsRoot'
	dst = append(dst, e.ReceiptsRoot[:]...)

	// Field (4) 'LogsBloom'
	dst = append(dst, e.LogsBloom[:]...)

	// Field (5) 'PrevRandao'
	dst = append(dst, e.PrevRandao[:]...)

	// Field (6) 'BlockNumber'
	dst = ssz.MarshalValue(dst, e.BlockNumber)

	// Field (7) 'GasLimit'
	dst = ssz.MarshalValue(dst, e.GasLimit)

	// Field (8) 'GasUsed'
	dst = ssz.MarshalValue(dst, e.GasUsed)

	// Field (9) 'Timestamp'
	dst = ssz.MarshalValue(dst, e.Timestamp)

	// Offset (10) 'ExtraData'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(e.ExtraData)

	// Field (11) 'BaseFeePerGas'
	dst = append(dst, e.BaseFeePerGas[:]...)

	// Field (12) 'BlockHash'
	dst = append(dst, e.BlockHash[:]...)

	// Offset (13) 'Transactions'
	dst = ssz.WriteOffset(dst, offset)
	for ii := 0; ii < len(e.Transactions); ii++ {
		offset += 4
		offset += len(e.Transactions[ii])
	}

	// Offset (14) 'Withdrawals'
	dst = ssz.WriteOffset(dst, offset)

	// Field (15) 'BlobGasUsed'
	dst = ssz.MarshalValue(dst, e.BlobGasUsed)

	// Field (16) 'ExcessBlobGas'
	dst = ssz.MarshalValue(dst, e.ExcessBlobGas)

	// Field (10) 'ExtraData'
	if size := uint64(len(e.ExtraData)); size > 32 {
		err = ssz.ErrBytesLengthFn("ExecutionPayload.ExtraData", size, 32)
		return
	}
	dst = append(dst, e.ExtraData...)

	// Field (13) 'Transactions'
	if size := uint64(len(e.Transactions)); size > 1048576 {
		err = ssz.ErrListTooBigFn("ExecutionPayload.Transactions", size, 1048576)
		return
	}
	{
		offset = 4 * len(e.Transactions)
		for ii := 0; ii < len(e.Transactions); ii++ {
			dst = ssz.WriteOffset(dst, offset)
			offset += len(e.Transactions[ii])
		}
	}
	for ii := 0; ii < len(e.Transactions); ii++ {
		if size := uint64(len(e.Transactions[ii])); size > 1073741824 {
			err = ssz.ErrBytesLengthFn("ExecutionPayload.Transactions[ii]", size, 1073741824)
			return
		}
		dst = append(dst, e.Transactions[ii]...)
	}

	// Field (14) 'Withdrawals'
	if size := uint64(len(e.Withdrawals)); size > maxWithdrawals {
		err = ssz.ErrListTooBigFn("ExecutionPayload.Withdrawals", size, maxWithdrawals)
		return
	}
	for ii := 0; ii < len(e.Withdrawals); ii++ {
		if dst, err = e.Withdrawals[ii].MarshalSSZTo(dst); err != nil {
			return
		}
	}

	return
}

// UnmarshalSSZ ssz unmarshals the ExecutionPayload object
func (e *ExecutionPayload) UnmarshalSSZ(buf []byte) error {
	return ssz.UnmarshalSSZ(e, buf)
}

// UnmarshalSSZTail unmarshals the ExecutionPayload object and returns the remaining bufferº
func (e *ExecutionPayload) UnmarshalSSZTail(buf []byte) (rest []byte, err error) {
	size := len(buf)
	fixedSize := e.fixedSize()
	if size < fixedSize {
		return nil, ssz.ErrSize
	}

	tail := buf
	var o10, o13, o14 uint64
	marker := ssz.NewOffsetMarker(uint64(size), uint64(fixedSize))

	// Field (0) 'ParentHash'
	buf = ssz.UnmarshalFixedBytes(e.ParentHash[:], buf)

	// Field (1) 'FeeRecipient'
	buf = ssz.UnmarshalFixedBytes(e.FeeRecipient[:], buf)

	// Field (2) 'StateRoot'
	buf = ssz.UnmarshalFixedBytes(e.StateRoot[:], buf)

	// Field (3) 'ReceiptsRoot'
	buf = ssz.UnmarshalFixedBytes(e.ReceiptsRoot[:], buf)

	// Field (4) 'LogsBloom'
	buf = ssz.UnmarshalFixedBytes(e.LogsBloom[:], buf)

	// Field (5) 'PrevRandao'
	buf = ssz.UnmarshalFixedBytes(e.PrevRandao[:], buf)

	// Field (6) 'BlockNumber'
	e.BlockNumber, buf = ssz.UnmarshallValue[uint64](buf)

	// Field (7) 'GasLimit'
	e.GasLimit, buf = ssz.UnmarshallValue[uint64](buf)

	// Field (8) 'GasUsed'
	e.GasUsed, buf = ssz.UnmarshallValue[uint64](buf)

	// Field (9) 'Timestamp'
	e.Timestamp, buf = ssz.UnmarshallValue[uint64](buf)

	// Offset (10) 'ExtraData'
	if o10, buf, err = marker.ReadOffset(buf); err != nil {
		return nil, err
	}

	// Field (11) 'BaseFeePerGas'
	buf = ssz.UnmarshalFixedBytes(e.BaseFeePerGas[:], buf)

	// Field (12) 'BlockHash'
	buf = ssz.UnmarshalFixedBytes(e.BlockHash[:], buf)

	// Offset (13) 'Transactions'
	if o13, buf, err = marker.ReadOffset(buf); err != nil {
		return nil, err
	}

	// Offset (14) 'Withdrawals'
	if o14, buf, err = marker.ReadOffset(buf); err != nil {
		return nil, err
	}

	// Field (15) 'BlobGasUsed'
	e.BlobGasUsed, buf = ssz.UnmarshallValue[uint64](buf)

	// Field (16) 'ExcessBlobGas'
	e.ExcessBlobGas, buf = ssz.UnmarshallValue[uint64](buf)

	// Field (10) 'ExtraData'
	if e.ExtraData, err = ssz.UnmarshalDynamicBytes(e.ExtraData, tail[o10:o13], 32); err != nil {
		return
	}

	// Field (13) 'Transactions'
	if err = ssz.UnmarshalDynamicSliceWithCallback(&e.Transactions, tail[o13:o14], 1048576, func(indx uint64, buf []byte) (err error) {
		if e.Transactions[indx], err = ssz.UnmarshalDynamicBytes(e.Transactions[indx], buf, 1073741824); err != nil {
			return
		}
		return nil
	}); err != nil {
		return nil, err
	}

	// Field (14) 'Withdrawals'
	if err = ssz.UnmarshalSliceSSZ(&e.Withdrawals, tail[o14:], maxWithdrawals); err != nil {
		return nil, err
	}

	return
}

// fixedSize returns the fixed size of the ExecutionPayload object
func (e *ExecutionPayload) fixedSize() int {
	return int(528)
}

// SizeSSZ returns the ssz encoded size in bytes for the ExecutionPayload object
func (e *ExecutionPayload) SizeSSZ() (size int) {
	size = e.fixedSize()

	// Field (10) 'ExtraData'
	size += len(e.ExtraData)

	// Field (13) 'Transactions'
	for ii := 0; ii < len(e.Transactions); ii++ {
		size += 4
		size += len(e.Transactions[ii])
	}

	// Field (14) 'Withdrawals'
	size += len(e.Withdrawals) * 44

	return
}

// HashTreeRoot ssz hashes the ExecutionPayload object
func (e *ExecutionPayload) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(e)
}

// HashTreeRootWith ssz hashes the ExecutionPayload object with a hasher
func (e *ExecutionPayload) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'ParentHash'
	hh.PutBytes(e.ParentHash[:])

	// Field (1) 'FeeRecipient'
	hh.PutBytes(e.FeeRecipient[:])

	// Field (2) 'StateRoot'
	hh.PutBytes(e.StateRoot[:])

	// Field (3) 'ReceiptsRoot'
	hh.PutBytes(e.ReceiptsRoot[:])

	// Field (4) 'LogsBloom'
	hh.PutBytes(e.LogsBloom[:])

	// Field (5) 'PrevRandao'
	hh.PutBytes(e.PrevRandao[:])

	// Field (6) 'BlockNumber'
	hh.PutUint64(e.BlockNumber)

	// Field (7) 'GasLimit'
	hh.PutUint64(e.GasLimit)

	// Field (8) 'GasUsed'
	hh.PutUint64(e.GasUsed)

	// Field (9) 'Timestamp'
	hh.PutUint64(e.Timestamp)

	// Field (10) 'ExtraData'
	{
		elemIndx := hh.Index()
		byteLen := uint64(len(e.ExtraData))
		if byteLen > 32 {
			err = ssz.ErrIncorrectListSize
			return
		}
		hh.Append(e.ExtraData)
		hh.MerkleizeWithMixin(elemIndx, byteLen, (32+31)/32)
	}

	// Field (11) 'BaseFeePerGas'
	hh.PutBytes(e.BaseFeePerGas[:])

	// Field (12) 'BlockHash'
	hh.PutBytes(e.BlockHash[:])

	// Field (13) 'Transactions'
	{
		subIndx := hh.Index()
		num := uint64(len(e.Transactions))
		if num > 1048576 {
			err = ssz.ErrIncorrectListSize
			return
		}
		for _, elem := range e.Transactions {
			{
				elemIndx := hh.Index()
				byteLen := uint64(len(elem))
				if byteLen > 1073741824 {
					err = ssz.ErrIncorrectListSize
					return
				}
				hh.AppendBytes32(elem)
				hh.MerkleizeWithMixin(elemIndx, byteLen, (1073741824+31)/32)
			}
		}
		hh.MerkleizeWithMixin(subIndx, num, 1048576)
	}

	// Field (14) 'Withdrawals'
	{
		subIndx := hh.Index()
		num := uint64(len(e.Withdrawals))
		if num > maxWithdrawals {
			err = ssz.ErrIncorrectListSize
			return
		}
		for _, elem := range e.Withdrawals {
			if err = elem.HashTreeRootWith(hh); err != nil {
				return
			}
		}
		hh.MerkleizeWithMixin(subIndx, num, maxWithdrawals)
	}

	// Field (15) 'BlobGasUsed'
	hh.PutUint64(e.BlobGasUsed)

	// Field (16) 'ExcessBlobGas'
	hh.PutUint64(e.ExcessBlobGas)

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the ExecutionPayload object
func (e *ExecutionPayload) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(e)
}

// MarshalSSZ ssz marshals the ExecutionPayloadHeader object
func (e *ExecutionPayloadHeader) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(e)
}

// MarshalSSZTo ssz marshals the ExecutionPayloadHeader object to a target array
func (e *ExecutionPayloadHeader) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := e.fixedSize()

	// Field (0) 'ParentHash'
	dst = append(dst, e.ParentHash[:]...)

	// Field (1) 'FeeRecipient'
	dst = append(dst, e.FeeRecipient[:]...)

	// Field (2) 'StateRoot'
	dst = append(dst, e.StateRoot[:]...)

	// Field (3) 'ReceiptsRoot'
	dst = append(dst, e.ReceiptsRoot[:]...)

	// Field (4) 'LogsBloom'
	dst = append(dst, e.LogsBloom[:]...)

	// Field (5) 'PrevRandao'
	dst = append(dst, e.PrevRandao[:]...)

	// Field (6) 'BlockNumber'
	dst = ssz.MarshalValue(dst, e.BlockNumber)

	// Field (7) 'GasLimit'
	dst = ssz.MarshalValue(dst, e.GasLimit)

	// Field (8) 'GasUsed'
	dst = ssz.MarshalValue(dst, e.GasUsed)

	// Field (9) 'Timestamp'
	dst = ssz.MarshalValue(dst, e.Timestamp)

	// Offset (10) 'ExtraData'
	dst = ssz.WriteOffset(dst, offset)

	// Field (11) 'BaseFeePerGas'
	dst = append(dst, e.BaseFeePerGas[:]...)

	// Field (12) 'BlockHash'
	dst = append(dst, e.BlockHash[:]...)

	// Field (13) 'TransactionsRoot'
	dst = append(dst, e.TransactionsRoot[:]...)

	// Field (14) 'WithdrawalsRoot'
	dst = append(dst, e.WithdrawalsRoot[:]...)

	// Field (15) 'BlobGasUsed'
	dst = ssz.MarshalValue(dst, e.BlobGasUsed)

	// Field (16) 'ExcessBlobGas'
	dst = ssz.MarshalValue(dst, e.ExcessBlobGas)

	// Field (10) 'ExtraData'
	if size := uint64(len(e.ExtraData)); size > 32 {
		err = ssz.ErrBytesLengthFn("ExecutionPayloadHeader.ExtraData", size, 32)
		return
	}
	dst = append(dst, e.ExtraData...)

	return
}

// UnmarshalSSZ ssz unmarshals the ExecutionPayloadHeader object
func (e *ExecutionPayloadHeader) UnmarshalSSZ(buf []byte) error {
	return ssz.UnmarshalSSZ(e, buf)
}

// UnmarshalSSZTail unmarshals the ExecutionPayloadHeader object and returns the remaining bufferº
func (e *ExecutionPayloadHeader) UnmarshalSSZTail(buf []byte) (rest []byte, err error) {
	size := len(buf)
	fixedSize := e.fixedSize()
	if size < fixedSize {
		return nil, ssz.ErrSize
	}

	tail := buf
	var o10 uint64
	marker := ssz.NewOffsetMarker(uint64(size), uint64(fixedSize))

	// Field (0) 'ParentHash'
	buf = ssz.UnmarshalFixedBytes(e.ParentHash[:], buf)

	// Field (1) 'FeeRecipient'
	buf = ssz.UnmarshalFixedBytes(e.FeeRecipient[:], buf)

	// Field (2) 'StateRoot'
	buf = ssz.UnmarshalFixedBytes(e.StateRoot[:], buf)

	// Field (3) 'ReceiptsRoot'
	buf = ssz.UnmarshalFixedBytes(e.ReceiptsRoot[:], buf)

	// Field (4) 'LogsBloom'
	buf = ssz.UnmarshalFixedBytes(e.LogsBloom[:], buf)

	// Field (5) 'PrevRandao'
	buf = ssz.UnmarshalFixedBytes(e.PrevRandao[:], buf)

	// Field (6) 'BlockNumber'
	e.BlockNumber, buf = ssz.UnmarshallValue[uint64](buf)

	// Field (7) 'GasLimit'
	e.GasLimit, buf = ssz.UnmarshallValue[uint64](buf)

	// Field (8) 'GasUsed'
	e.GasUsed, buf = ssz.UnmarshallValue[uint64](buf)

	// Field (9) 'Timestamp'
	e.Timestamp, buf = ssz.UnmarshallValue[uint64](buf)

	// Offset (10) 'ExtraData'
	if o10, buf, err = marker.ReadOffset(buf); err != nil {
		return nil, err
	}

	// Field (11) 'BaseFeePerGas'
	buf = ssz.UnmarshalFixedBytes(e.BaseFeePerGas[:], buf)

	// Field (12) 'BlockHash'
	buf = ssz.UnmarshalFixedBytes(e.BlockHash[:], buf)

	// Field (13) 'TransactionsRoot'
	buf = ssz.UnmarshalFixedBytes(e.TransactionsRoot[:], buf)

	// Field (14) 'WithdrawalsRoot'
	buf = ssz.UnmarshalFixedBytes(e.WithdrawalsRoot[:], buf)

	// Field (15) 'BlobGasUsed'
	e.BlobGasUsed, buf = ssz.UnmarshallValue[uint64](buf)

	// Field (16) 'ExcessBlobGas'
	e.ExcessBlobGas, buf = ssz.UnmarshallValue[uint64](buf)

	// Field (10) 'ExtraData'
	if e.ExtraData, err = ssz.UnmarshalDynamicBytes(e.ExtraData, tail[o10:], 32); err != nil {
		return
	}

	return
}

// fixedSize returns the fixed size of the ExecutionPayloadHeader object
func (e *ExecutionPayloadHeader) fixedSize() int {
	return int(584)
}

// SizeSSZ returns the ssz encoded size in bytes for the ExecutionPayloadHeader object
func (e *ExecutionPayloadHeader) SizeSSZ() (size int) {
	size = e.fixedSize()

	// Field (10) 'ExtraData'
	size += len(e.ExtraData)

	return
}

// HashTreeRoot ssz hashes the ExecutionPayloadHeader object
func (e *ExecutionPayloadHeader) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(e)
}

// HashTreeRootWith ssz hashes the ExecutionPayloadHeader object with a hasher
func (e *ExecutionPayloadHeader) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'ParentHash'
	hh.PutBytes(e.ParentHash[:])

	// Field (1) 'FeeRecipient'
	hh.PutBytes(e.FeeRecipient[:])

	// Field (2) 'StateRoot'
	hh.PutBytes(e.StateRoot[:])

	// Field (3) 'ReceiptsRoot'
	hh.PutBytes(e.ReceiptsRoot[:])

	// Field (4) 'LogsBloom'
	hh.PutBytes(e.LogsBloom[:])

	// Field (5) 'PrevRandao'
	hh.PutBytes(e.PrevRandao[:])

	// Field (6) 'BlockNumber'
	hh.PutUint64(e.BlockNumber)

	// Field (7) 'GasLimit'
	hh.PutUint64(e.GasLimit)

	// Field (8) 'GasUsed'
	hh.PutUint64(e.GasUsed)

	// Field (9) 'Timestamp'
	hh.PutUint64(e.Timestamp)

	// Field (10) 'ExtraData'
	{
		elemIndx := hh.Index()
		byteLen := uint64(len(e.ExtraData))
		if byteLen > 32 {
			err = ssz.ErrIncorrectListSize
			return
		}
		hh.Append(e.ExtraData)
		hh.MerkleizeWithMixin(elemIndx, byteLen, (32+31)/32)
	}

	// Field (11) 'BaseFeePerGas'
	hh.PutBytes(e.BaseFeePerGas[:])

	// Field (12) 'BlockHash'
	hh.PutBytes(e.BlockHash[:])

	// Field (13) 'TransactionsRoot'
	hh.PutBytes(e.TransactionsRoot[:])

	// Field (14) 'WithdrawalsRoot'
	hh.PutBytes(e.WithdrawalsRoot[:])

	// Field (15) 'BlobGasUsed'
	hh.PutUint64(e.BlobGasUsed)

	// Field (16) 'ExcessBlobGas'
	hh.PutUint64(e.ExcessBlobGas)

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the ExecutionPayloadHeader object
func (e *ExecutionPayloadHeader) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(e)
}

// MarshalSSZ ssz marshals the BeaconBlockBody object
func (b *BeaconBlockBody) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(b)
}

// MarshalSSZTo ssz marshals the BeaconBlockBody object to a target array
func (b *BeaconBlockBody) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := b.fixedSize()

	// Field (0) 'RANDAOReveal'
	dst = append(dst, b.RANDAOReveal[:]...)

	// Field (1) 'ETH1Data'
	if b.ETH1Data == nil {
		b.ETH1Data = new(ETH1Data)
	}
	if dst, err = b.ETH1Data.MarshalSSZTo(dst); err != nil {
		return
	}

	// Field (2) 'Graffiti'
	dst = append(dst, b.Graffiti[:]...)

	// Offset (3) 'ProposerSlashings'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(b.ProposerSlashings) * 416

	// Offset (4) 'AttesterSlashings'
	dst = ssz.WriteOffset(dst, offset)
	for ii := 0; ii < len(b.AttesterSlashings); ii++ {
		offset += 4
		offset += b.AttesterSlashings[ii].SizeSSZ()
	}

	// Offset (5) 'Attestations'
	dst = ssz.WriteOffset(dst, offset)
	for ii := 0; ii < len(b.Attestations); ii++ {
		offset += 4
		offset += b.Attestations[ii].SizeSSZ()
	}

	// Offset (6) 'Deposits'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(b.Deposits) * 1240

	// Offset (7) 'VoluntaryExits'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(b.VoluntaryExits) * 112

	// Field (8) 'SyncAggregate'
	if b.SyncAggregate == nil {
		b.SyncAggregate = new(SyncAggregate)
	}
	if dst, err = b.SyncAggregate.MarshalSSZTo(dst); err != nil {
		return
	}

	// Offset (9) 'ExecutionPayload'
	dst = ssz.WriteOffset(dst, offset)
	if b.ExecutionPayload == nil {
		b.ExecutionPayload = new(ExecutionPayload)
	}
	offset += b.ExecutionPayload.SizeSSZ()

	// Offset (10) 'BLSToExecutionChanges'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(b.BLSToExecutionChanges) * 172

	// Offset (11) 'BlobKZGCommitments'
	dst = ssz.WriteOffset(dst, offset)

	// Field (3) 'ProposerSlashings'
	if size := uint64(len(b.ProposerSlashings)); size > 16 {
		err = ssz.ErrListTooBigFn("BeaconBlockBody.ProposerSlashings", size, 16)
		return
	}
	for ii := 0; ii < len(b.ProposerSlashings); ii++ {
		if dst, err = b.ProposerSlashings[ii].MarshalSSZTo(dst); err != nil {
			return
		}
	}

	// Field (4) 'AttesterSlashings'
	if size := uint64(len(b.AttesterSlashings)); size > 2 {
		err = ssz.ErrListTooBigFn("BeaconBlockBody.AttesterSlashings", size, 2)
		return
	}
	{
		offset = 4 * len(b.AttesterSlashings)
		for ii := 0; ii < len(b.AttesterSlashings); ii++ {
			dst = ssz.WriteOffset(dst, offset)
			offset += b.AttesterSlashings[ii].SizeSSZ()
		}
	}
	for ii := 0; ii < len(b.AttesterSlashings); ii++ {
		if dst, err = b.AttesterSlashings[ii].MarshalSSZTo(dst); err != nil {
			return
		}
	}

	// Field (5) 'Attestations'
	if size := uint64(len(b.Attestations)); size > 128 {
		err = ssz.ErrListTooBigFn("BeaconBlockBody.Attestations", size, 128)
		return
	}
	{
		offset = 4 * len(b.Attestations)
		for ii := 0; ii < len(b.Attestations); ii++ {
			dst = ssz.WriteOffset(dst, offset)
			offset += b.Attestations[ii].SizeSSZ()
		}
	}
	for ii := 0; ii < len(b.Attestations); ii++ {
		if dst, err = b.Attestations[ii].MarshalSSZTo(dst); err != nil {
			return
		}
	}

	// Field (6) 'Deposits'
	if size := uint64(len(b.Deposits)); size > 16 {
		err = ssz.ErrListTooBigFn("BeaconBlockBody.Deposits", size, 16)
		return
	}
	for ii := 0; ii < len(b.Deposits); ii++ {
		if dst, err = b.Deposits[ii].MarshalSSZTo(dst); err != nil {
			return
		}
	}

	// Field (7) 'VoluntaryExits'
	if size := uint64(len(b.VoluntaryExits)); size > 16 {
		err = ssz.ErrListTooBigFn("BeaconBlockBody.VoluntaryExits", size, 16)
		return
	}
	for ii := 0; ii < len(b.VoluntaryExits); ii++ {
		if dst, err = b.VoluntaryExits[ii].MarshalSSZTo(dst); err != nil {
			return
		}
	}

	// Field (9) 'ExecutionPayload'
	if dst, err = b.ExecutionPayload.MarshalSSZTo(dst); err != nil {
		return
	}

	// Field (10) 'BLSToExecutionChanges'
	if size := uint64(len(b.BLSToExecutionChanges)); size > 16 {
		err = ssz.ErrListTooBigFn("BeaconBlockBody.BLSToExecutionChanges", size, 16)
		return
	}
	for ii := 0; ii < len(b.BLSToExecutionChanges); ii++ {
		if dst, err = b.BLSToExecutionChanges[ii].MarshalSSZTo(dst); err != nil {
			return
		}
	}

	// Field (11) 'BlobKZGCommitments'
	if size := uint64(len(b.BlobKZGCommitments)); size > maxBlobCommitmentsPerBlock {
		err = ssz.ErrListTooBigFn("BeaconBlockBody.BlobKZGCommitments", size, maxBlobCommitmentsPerBlock)
		return
	}
	for ii := 0; ii < len(b.BlobKZGCommitments); ii++ {
		dst = append(dst, b.BlobKZGCommitments[ii][:]...)
	}

	return
}

// UnmarshalSSZ ssz unmarshals the BeaconBlockBody object
func (b *BeaconBlockBody) UnmarshalSSZ(buf []byte) error {
	return ssz.UnmarshalSSZ(b, buf)
}

// UnmarshalSSZTail unmarshals the BeaconBlockBody object and returns the remaining bufferº
func (b *BeaconBlockBody) UnmarshalSSZTail(buf []byte) (rest []byte, err error) {
	size := len(buf)
	fixedSize := b.fixedSize()
	if size < fixedSize {
		return nil, ssz.ErrSize
	}

	tail := buf
	var o3, o4, o5, o6, o7, o9, o10, o11 uint64
	marker := ssz.NewOffsetMarker(uint64(size), uint64(fixedSize))

	// Field (0) 'RANDAOReveal'
	buf = ssz.UnmarshalFixedBytes(b.RANDAOReveal[:], buf)

	// Field (1) 'ETH1Data'
	if buf, err = ssz.UnmarshalFieldTail(&b.ETH1Data, buf); err != nil {
		return
	}

	// Field (2) 'Graffiti'
	buf = ssz.UnmarshalFixedBytes(b.Graffiti[:], buf)

	// Offset (3) 'ProposerSlashings'
	if o3, buf, err = marker.ReadOffset(buf); err != nil {
		return nil, err
	}

	// Offset (4) 'AttesterSlashings'
	if o4, buf, err = marker.ReadOffset(buf); err != nil {
		return nil, err
	}

	// Offset (5) 'Attestations'
	if o5, buf, err = marker.ReadOffset(buf); err != nil {
		return nil, err
	}

	// Offset (6) 'Deposits'
	if o6, buf, err = marker.ReadOffset(buf); err != nil {
		return nil, err
	}

	// Offset (7) 'VoluntaryExits'
	if o7, buf, err = marker.ReadOffset(buf); err != nil {
		return nil, err
	}

	// Field (8) 'SyncAggregate'
	if buf, err = ssz.UnmarshalFieldTail(&b.SyncAggregate, buf); err != nil {
		return
	}

	// Offset (9) 'ExecutionPayload'
	if o9, buf, err = marker.ReadOffset(buf); err != nil {
		return nil, err
	}

	// Offset (10) 'BLSToExecutionChanges'
	if o10, buf, err = marker.ReadOffset(buf); err != nil {
		return nil, err
	}

	// Offset (11) 'BlobKZGCommitments'
	if o11, _, err = marker.ReadOffset(buf); err != nil {
		return nil, err
	}

	// Field (3) 'ProposerSlashings'
	if err = ssz.UnmarshalSliceSSZ(&b.ProposerSlashings, tail[o3:o4], 16); err != nil {
		return nil, err
	}

	// Field (4) 'AttesterSlashings'
	if err = ssz.UnmarshalDynamicSliceSSZ(&b.AttesterSlashings, tail[o4:o5], 2); err != nil {
		return nil, err
	}

	// Field (5) 'Attestations'
	if err = ssz.UnmarshalDynamicSliceSSZ(&b.Attestations, tail[o5:o6], 128); err != nil {
		return nil, err
	}

	// Field (6) 'Deposits'
	if err = ssz.UnmarshalSliceSSZ(&b.Deposits, tail[o6:o7], 16); err != nil {
		return nil, err
	}

	// Field (7) 'VoluntaryExits'
	if err = ssz.UnmarshalSliceSSZ(&b.VoluntaryExits, tail[o7:o9], 16); err != nil {
		return nil, err
	}

	// Field (9) 'ExecutionPayload'
	if err = ssz.UnmarshalField(&b.ExecutionPayload, tail[o9:o10]); err != nil {
		return
	}

	// Field (10) 'BLSToExecutionChanges'
	if err = ssz.UnmarshalSliceSSZ(&b.BLSToExecutionChanges, tail[o10:o11], 16); err != nil {
		return nil, err
	}

	// Field (11) 'BlobKZGCommitments'
	if err = ssz.UnmarshalSliceWithIndexCallback(&b.BlobKZGCommitments, tail[o11:], 48, maxBlobCommitmentsPerBlock, func(ii uint64, buf []byte) (err error) {
		buf = ssz.UnmarshalFixedBytes(b.BlobKZGCommitments[ii][:], buf)
		return nil
	}); err != nil {
		return nil, err
	}

	return
}

// fixedSize returns the fixed size of the BeaconBlockBody object
func (b *BeaconBlockBody) fixedSize() int {
	return int((232 + (96 + syncCommitteeBitsSize)))
}

// SizeSSZ returns the ssz encoded size in bytes for the BeaconBlockBody object
func (b *BeaconBlockBody) SizeSSZ() (size int) {
	size = b.fixedSize()

	// Field (3) 'ProposerSlashings'
	size += len(b.ProposerSlashings) * 416

	// Field (4) 'AttesterSlashings'
	for ii := 0; ii < len(b.AttesterSlashings); ii++ {
		size += 4
		size += b.AttesterSlashings[ii].SizeSSZ()
	}

	// Field (5) 'Attestations'
	for ii := 0; ii < len(b.Attestations); ii++ {
		size += 4
		size += b.Attestations[ii].SizeSSZ()
	}

	// Field (6) 'Deposits'
	size += len(b.Deposits) * 1240

	// Field (7) 'VoluntaryExits'
	size += len(b.VoluntaryExits) * 112

	// Field (9) 'ExecutionPayload'
	if b.ExecutionPayload == nil {
		b.ExecutionPayload = new(ExecutionPayload)
	}
	size += b.ExecutionPayload.SizeSSZ()

	// Field (10) 'BLSToExecutionChanges'
	size += len(b.BLSToExecutionChanges) * 172

	// Field (11) 'BlobKZGCommitments'
	size += len(b.BlobKZGCommitments) * 48

	return
}

// HashTreeRoot ssz hashes the BeaconBlockBody object
func (b *BeaconBlockBody) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(b)
}

// HashTreeRootWith ssz hashes the BeaconBlockBody object with a hasher
func (b *BeaconBlockBody) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'RANDAOReveal'
	hh.PutBytes(b.RANDAOReveal[:])

	// Field (1) 'ETH1Data'
	if b.ETH1Data == nil {
		b.ETH1Data = new(ETH1Data)
	}
	if err = b.ETH1Data.HashTreeRootWith(hh); err != nil {
		return
	}

	// Field (2) 'Graffiti'
	hh.PutBytes(b.Graffiti[:])

	// Field (3) 'ProposerSlashings'
	{
		subIndx := hh.Index()
		num := uint64(len(b.ProposerSlashings))
		if num > 16 {
			err = ssz.ErrIncorrectListSize
			return
		}
		for _, elem := range b.ProposerSlashings {
			if err = elem.HashTreeRootWith(hh); err != nil {
				return
			}
		}
		hh.MerkleizeWithMixin(subIndx, num, 16)
	}

	// Field (4) 'AttesterSlashings'
	{
		subIndx := hh.Index()
		num := uint64(len(b.AttesterSlashings))
		if num > 2 {
			err = ssz.ErrIncorrectListSize
			return
		}
		for _, elem := range b.AttesterSlashings {
			if err = elem.HashTreeRootWith(hh); err != nil {
				return
			}
		}
		hh.MerkleizeWithMixin(subIndx, num, 2)
	}

	// Field (5) 'Attestations'
	{
		subIndx := hh.Index()
		num := uint64(len(b.Attestations))
		if num > 128 {
			err = ssz.ErrIncorrectListSize
			return
		}
		for _, elem := range b.Attestations {
			if err = elem.HashTreeRootWith(hh); err != nil {
				return
			}
		}
		hh.MerkleizeWithMixin(subIndx, num, 128)
	}

	// Field (6) 'Deposits'
	{
		subIndx := hh.Index()
		num := uint64(len(b.Deposits))
		if num > 16 {
			err = ssz.ErrIncorrectListSize
			return
		}
		for _, elem := range b.Deposits {
			if err = elem.HashTreeRootWith(hh); err != nil {
				return
			}
		}
		hh.MerkleizeWithMixin(subIndx, num, 16)
	}

	// Field (7) 'VoluntaryExits'
	{
		subIndx := hh.Index()
		num := uint64(len(b.VoluntaryExits))
		if num > 16 {
			err = ssz.ErrIncorrectListSize
			return
		}
		for _, elem := range b.VoluntaryExits {
			if err = elem.HashTreeRootWith(hh); err != nil {
				return
			}
		}
		hh.MerkleizeWithMixin(subIndx, num, 16)
	}

	// Field (8) 'SyncAggregate'
	if b.SyncAggregate == nil {
		b.SyncAggregate = new(SyncAggregate)
	}
	if err = b.SyncAggregate.HashTreeRootWith(hh); err != nil {
		return
	}

	// Field (9) 'ExecutionPayload'
	if err = b.ExecutionPayload.HashTreeRootWith(hh); err != nil {
		return
	}

	// Field (10) 'BLSToExecutionChanges'
	{
		subIndx := hh.Index()
		num := uint64(len(b.BLSToExecutionChanges))
		if num > 16 {
			err = ssz.ErrIncorrectListSize
			return
		}
		for _, elem := range b.BLSToExecutionChanges {
			if err = elem.HashTreeRootWith(hh); err != nil {
				return
			}
		}
		hh.MerkleizeWithMixin(subIndx, num, 16)
	}

	// Field (11) 'BlobKZGCommitments'
	{
		if size := uint64(len(b.BlobKZGCommitments)); size > maxBlobCommitmentsPerBlock {
			err = ssz.ErrListTooBigFn("BeaconBlockBody.BlobKZGCommitments", size, maxBlobCommitmentsPerBlock)
			return
		}
		subIndx := hh.Index()
		for _, i := range b.BlobKZGCommitments {
			hh.PutBytes(i[:])
		}
		numItems := uint64(len(b.BlobKZGCommitments))
		hh.MerkleizeWithMixin(subIndx, numItems, maxBlobCommitmentsPerBlock)
	}

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the BeaconBlockBody object
func (b *BeaconBlockBody) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(b)
}

// MarshalSSZ ssz marshals the BeaconBlock object
func (b *BeaconBlock) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(b)
}

// MarshalSSZTo ssz marshals the BeaconBlock object to a target array
func (b *BeaconBlock) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := b.fixedSize()

	// Field (0) 'Slot'
	dst = ssz.MarshalValue(dst, uint64(b.Slot))

	// Field (1) 'ProposerIndex'
	dst = ssz.MarshalValue(dst, uint64(b.ProposerIndex))

	// Field (2) 'ParentRoot'
	dst = append(dst, b.ParentRoot[:]...)

	// Field (3) 'StateRoot'
	dst = append(dst, b.StateRoot[:]...)

	// Offset (4) 'Body'
	dst = ssz.WriteOffset(dst, offset)

	// Field (4) 'Body'
	if dst, err = b.Body.MarshalSSZTo(dst); err != nil {
		return
	}

	return
}

// UnmarshalSSZ ssz unmarshals the BeaconBlock object
func (b *BeaconBlock) UnmarshalSSZ(buf []byte) error {
	return ssz.UnmarshalSSZ(b, buf)
}

// UnmarshalSSZTail unmarshals the BeaconBlock object and returns the remaining bufferº
func (b *BeaconBlock) UnmarshalSSZTail(buf []byte) (rest []byte, err error) {
	size := len(buf)
	fixedSize := b.fixedSize()
	if size < fixedSize {
		return nil, ssz.ErrSize
	}

	tail := buf
	var o4 uint64
	marker := ssz.NewOffsetMarker(uint64(size), uint64(fixedSize))

	// Field (0) 'Slot'
	{
		var val uint64
		val, buf = ssz.UnmarshallValue[uint64](buf)
		b.Slot = Slot(val)
	}

	// Field (1) 'ProposerIndex'
	{
		var val uint64
		val, buf = ssz.UnmarshallValue[uint64](buf)
		b.ProposerIndex = ValidatorIndex(val)
	}

	// Field (2) 'ParentRoot'
	buf = ssz.UnmarshalFixedBytes(b.ParentRoot[:], buf)

	// Field (3) 'StateRoot'
	buf = ssz.UnmarshalFixedBytes(b.StateRoot[:], buf)

	// Offset (4) 'Body'
	if o4, _, err = marker.ReadOffset(buf); err != nil {
		return nil, err
	}

	// Field (4) 'Body'
	if err = ssz.UnmarshalField(&b.Body, tail[o4:]); err != nil {
		return
	}

	return
}

// fixedSize returns the fixed size of the BeaconBlock object
func (b *BeaconBlock) fixedSize() int {
	return int(84)
}

// SizeSSZ returns the ssz encoded size in bytes for the BeaconBlock object
func (b *BeaconBlock) SizeSSZ() (size int) {
	size = b.fixedSize()

	// Field (4) 'Body'
	if b.Body == nil {
		b.Body = new(BeaconBlockBody)
	}
	size += b.Body.SizeSSZ()

	return
}

// HashTreeRoot ssz hashes the BeaconBlock object
func (b *BeaconBlock) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(b)
}

// HashTreeRootWith ssz hashes the BeaconBlock object with a hasher
func (b *BeaconBlock) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'Slot'
	hh.PutUint64(uint64(b.Slot))

	// Field (1) 'ProposerIndex'
	hh.PutUint64(uint64(b.ProposerIndex))

	// Field (2) 'ParentRoot'
	hh.PutBytes(b.ParentRoot[:])

	// Field (3) 'StateRoot'
	hh.PutBytes(b.StateRoot[:])

	// Field (4) 'Body'
	if err = b.Body.HashTreeRootWith(hh); err != nil {
		return
	}

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the BeaconBlock object
func (b *BeaconBlock) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(b)
}

// MarshalSSZ ssz marshals the SignedBeaconBlock object
func (s *SignedBeaconBlock) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(s)
}

// MarshalSSZTo ssz marshals the SignedBeaconBlock object to a target array
func (s *SignedBeaconBlock) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := s.fixedSize()

	// Offset (0) 'Message'
	dst = ssz.WriteOffset(dst, offset)

	// Field (1) 'Signature'
	dst = append(dst, s.Signature[:]...)

	// Field (0) 'Message'
	if dst, err = s.Message.MarshalSSZTo(dst); err != nil {
		return
	}

	return
}

// UnmarshalSSZ ssz unmarshals the SignedBeaconBlock object
func (s *SignedBeaconBlock) UnmarshalSSZ(buf []byte) error {
	return ssz.UnmarshalSSZ(s, buf)
}

// UnmarshalSSZTail unmarshals the SignedBeaconBlock object and returns the remaining bufferº
func (s *SignedBeaconBlock) UnmarshalSSZTail(buf []byte) (rest []byte, err error) {
	size := len(buf)
	fixedSize := s.fixedSize()
	if size < fixedSize {
		return nil, ssz.ErrSize
	}

	tail := buf
	var o0 uint64
	marker := ssz.NewOffsetMarker(uint64(size), uint64(fixedSize))

	// Offset (0) 'Message'
	if o0, buf, err = marker.ReadOffset(buf); err != nil {
		return nil, err
	}

	// Field (1) 'Signature'
	buf = ssz.UnmarshalFixedBytes(s.Signature[:], buf)

	// Field (0) 'Message'
	if err = ssz.UnmarshalField(&s.Message, tail[o0:]); err != nil {
		return
	}

	return
}

// fixedSize returns the fixed size of the SignedBeaconBlock object
func (s *SignedBeaconBlock) fixedSize() int {
	return int(100)
}

// SizeSSZ returns the ssz encoded size in bytes for the SignedBeaconBlock object
func (s *SignedBeaconBlock) SizeSSZ() (size int) {
	size = s.fixedSize()

	// Field (0) 'Message'
	if s.Message == nil {
		s.Message = new(BeaconBlock)
	}
	size += s.Message.SizeSSZ()

	return
}

// HashTreeRoot ssz hashes the SignedBeaconBlock object
func (s *SignedBeaconBlock) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(s)
}

// HashTreeRootWith ssz hashes the SignedBeaconBlock object with a hasher
func (s *SignedBeaconBlock) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'Message'
	if err = s.Message.HashTreeRootWith(hh); err != nil {
		return
	}

	// Field (1) 'Signature'
	hh.PutBytes(s.Signature[:])

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the SignedBeaconBlock object
func (s *SignedBeaconBlock) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(s)
}

// MarshalSSZ ssz marshals the BeaconState object
func (b *BeaconState) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(b)
}

// MarshalSSZTo ssz marshals the BeaconState object to a target array
func (b *BeaconState) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := b.fixedSize()

	// Field (0) 'GenesisTime'
	dst = ssz.MarshalValue(dst, b.GenesisTime)

	// Field (1) 'GenesisValidatorsRoot'
	dst = append(dst, b.GenesisValidatorsRoot[:]...)

	// Field (2) 'Slot'
	dst = ssz.MarshalValue(dst, uint64(b.Slot))

	// Field (3) 'Fork'
	if b.Fork == nil {
		b.Fork = new(Fork)
	}
	if dst, err = b.Fork.MarshalSSZTo(dst); err != nil {
		return
	}

	// Field (4) 'LatestBlockHeader'
	if b.LatestBlockHeader == nil {
		b.LatestBlockHeader = new(BeaconBlockHeader)
	}
	if dst, err = b.LatestBlockHeader.MarshalSSZTo(dst); err != nil {
		return
	}

	// Field (5) 'BlockRoots'
	if size := uint64(len(b.BlockRoots)); size != slotsPerHistoricalRoot {
		err = ssz.ErrVectorLengthFn("BeaconState.BlockRoots", size, slotsPerHistoricalRoot)
		return
	}
	for ii := uint64(0); ii < slotsPerHistoricalRoot; ii++ {
		if size := uint64(len(b.BlockRoots[ii])); size != 32 {
			err = ssz.ErrBytesLengthFn("BeaconState.BlockRoots[ii]", size, 32)
			return
		}
		dst = append(dst, b.BlockRoots[ii]...)
	}

	// Field (6) 'StateRoots'
	if size := uint64(len(b.StateRoots)); size != slotsPerHistoricalRoot {
		err = ssz.ErrVectorLengthFn("BeaconState.StateRoots", size, slotsPerHistoricalRoot)
		return
	}
	for ii := uint64(0); ii < slotsPerHistoricalRoot; ii++ {
		if size := uint64(len(b.StateRoots[ii])); size != 32 {
			err = ssz.ErrBytesLengthFn("BeaconState.StateRoots[ii]", size, 32)
			return
		}
		dst = append(dst, b.StateRoots[ii]...)
	}

	// Offset (7) 'HistoricalRoots'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(b.HistoricalRoots) * 32

	// Field (8) 'ETH1Data'
	if b.ETH1Data == nil {
		b.ETH1Data = new(ETH1Data)
	}
	if dst, err = b.ETH1Data.MarshalSSZTo(dst); err != nil {
		return
	}

	// Offset (9) 'ETH1DataVotes'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(b.ETH1DataVotes) * 72

	// Field (10) 'ETH1DepositIndex'
	dst = ssz.MarshalValue(dst, b.ETH1DepositIndex)

	// Offset (11) 'Validators'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(b.Validators) * 121

	// Offset (12) 'Balances'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(b.Balances) * 8

	// Field (13) 'RANDAOMixes'
	if size := uint64(len(b.RANDAOMixes)); size != epochsPerHistoricalVector {
		err = ssz.ErrVectorLengthFn("BeaconState.RANDAOMixes", size, epochsPerHistoricalVector)
		return
	}
	for ii := uint64(0); ii < epochsPerHistoricalVector; ii++ {
		if size := uint64(len(b.RANDAOMixes[ii])); size != 32 {
			err = ssz.ErrBytesLengthFn("BeaconState.RANDAOMixes[ii]", size, 32)
			return
		}
		dst = append(dst, b.RANDAOMixes[ii]...)
	}

	// Field (14) 'Slashings'
	if size := uint64(len(b.Slashings)); size != epochsPerSlashingsVector {
		err = ssz.ErrVectorLengthFn("BeaconState.Slashings", size, epochsPerSlashingsVector)
		return
	}
	for ii := uint64(0); ii < epochsPerSlashingsVector; ii++ {
		dst = ssz.MarshalValue(dst, uint64(b.Slashings[ii]))
	}

	// Offset (15) 'PreviousEpochParticipation'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(b.PreviousEpochParticipation) * 1

	// Offset (16) 'CurrentEpochParticipation'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(b.CurrentEpochParticipation) * 1

	// Field (17) 'JustificationBits'
	dst = append(dst, b.JustificationBits[:]...)

	// Field (18) 'PreviousJustifiedCheckpoint'
	if b.PreviousJustifiedCheckpoint == nil {
		b.PreviousJustifiedCheckpoint = new(Checkpoint)
	}
	if dst, err = b.PreviousJustifiedCheckpoint.MarshalSSZTo(dst); err != nil {
		return
	}

	// Field (19) 'CurrentJustifiedCheckpoint'
	if b.CurrentJustifiedCheckpoint == nil {
		b.CurrentJustifiedCheckpoint = new(Checkpoint)
	}
	if dst, err = b.CurrentJustifiedCheckpoint.MarshalSSZTo(dst); err != nil {
		return
	}

	// Field (20) 'FinalizedCheckpoint'
	if b.FinalizedCheckpoint == nil {
		b.FinalizedCheckpoint = new(Checkpoint)
	}
	if dst, err = b.FinalizedCheckpoint.MarshalSSZTo(dst); err != nil {
		return
	}

	// Offset (21) 'InactivityScores'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(b.InactivityScores) * 8

	// Field (22) 'CurrentSyncCommittee'
	if b.CurrentSyncCommittee == nil {
		b.CurrentSyncCommittee = new(SyncCommittee)
	}
	if dst, err = b.CurrentSyncCommittee.MarshalSSZTo(dst); err != nil {
		return
	}

	// Field (23) 'NextSyncCommittee'
	if b.NextSyncCommittee == nil {
		b.NextSyncCommittee = new(SyncCommittee)
	}
	if dst, err = b.NextSyncCommittee.MarshalSSZTo(dst); err != nil {
		return
	}

	// Offset (24) 'LatestExecutionPayloadHeader'
	dst = ssz.WriteOffset(dst, offset)
	if b.LatestExecutionPayloadHeader == nil {
		b.LatestExecutionPayloadHeader = new(ExecutionPayloadHeader)
	}
	offset += b.LatestExecutionPayloadHeader.SizeSSZ()

	// Field (25) 'NextWithdrawalIndex'
	dst = ssz.MarshalValue(dst, uint64(b.NextWithdrawalIndex))

	// Field (26) 'NextWithdrawalValidatorIndex'
	dst = ssz.MarshalValue(dst, uint64(b.NextWithdrawalValidatorIndex))

	// Offset (27) 'HistoricalSummaries'
	dst = ssz.WriteOffset(dst, offset)

	// Field (7) 'HistoricalRoots'
	if size := uint64(len(b.HistoricalRoots)); size > 16777216 {
		err = ssz.ErrListTooBigFn("BeaconState.HistoricalRoots", size, 16777216)
		return
	}
	for ii := 0; ii < len(b.HistoricalRoots); ii++ {
		dst = append(dst, b.HistoricalRoots[ii][:]...)
	}

	// Field (9) 'ETH1DataVotes'
	if size := uint64(len(b.ETH1DataVotes)); size > eth1DataVotesLimit {
		err = ssz.ErrListTooBigFn("BeaconState.ETH1DataVotes", size, eth1DataVotesLimit)
		return
	}
	for ii := 0; ii < len(b.ETH1DataVotes); ii++ {
		if dst, err = b.ETH1DataVotes[ii].MarshalSSZTo(dst); err != nil {
			return
		}
	}

	// Field (11) 'Validators'
	if size := uint64(len(b.Validators)); size > 1099511627776 {
		err = ssz.ErrListTooBigFn("BeaconState.Validators", size, 1099511627776)
		return
	}
	for ii := 0; ii < len(b.Validators); ii++ {
		if dst, err = b.Validators[ii].MarshalSSZTo(dst); err != nil {
			return
		}
	}

	// Field (12) 'Balances'
	if size := uint64(len(b.Balances)); size > 1099511627776 {
		err = ssz.ErrListTooBigFn("BeaconState.Balances", size, 1099511627776)
		return
	}
	for ii := 0; ii < len(b.Balances); ii++ {
		dst = ssz.MarshalValue(dst, uint64(b.Balances[ii]))
	}

	// Field (15) 'PreviousEpochParticipation'
	if size := uint64(len(b.PreviousEpochParticipation)); size > 1099511627776 {
		err = ssz.ErrListTooBigFn("BeaconState.PreviousEpochParticipation", size, 1099511627776)
		return
	}
	for ii := 0; ii < len(b.PreviousEpochParticipation); ii++ {
		dst = ssz.MarshalValue(dst, uint8(b.PreviousEpochParticipation[ii]))
	}

	// Field (16) 'CurrentEpochParticipation'
	if size := uint64(len(b.CurrentEpochParticipation)); size > 1099511627776 {
		err = ssz.ErrListTooBigFn("BeaconState.CurrentEpochParticipation", size, 1099511627776)
		return
	}
	for ii := 0; ii < len(b.CurrentEpochParticipation); ii++ {
		dst = ssz.MarshalValue(dst, uint8(b.CurrentEpochParticipation[ii]))
	}

	// Field (21) 'InactivityScores'
	if size := uint64(len(b.InactivityScores)); size > 1099511627776 {
		err = ssz.ErrListTooBigFn("BeaconState.InactivityScores", size, 1099511627776)
		return
	}
	for ii := 0; ii < len(b.InactivityScores); ii++ {
		dst = ssz.MarshalValue(dst, b.InactivityScores[ii])
	}

	// Field (24) 'LatestExecutionPayloadHeader'
	if dst, err = b.LatestExecutionPayloadHeader.MarshalSSZTo(dst); err != nil {
		return
	}

	// Field (27) 'HistoricalSummaries'
	if size := uint64(len(b.HistoricalSummaries)); size > 16777216 {
		err = ssz.ErrListTooBigFn("BeaconState.HistoricalSummaries", size, 16777216)
		return
	}
	for ii := 0; ii < len(b.HistoricalSummaries); ii++ {
		if dst, err = b.HistoricalSummaries[ii].MarshalSSZTo(dst); err != nil {
			return
		}
	}

	return
}

// UnmarshalSSZ ssz unmarshals the BeaconState object
func (b *BeaconState) UnmarshalSSZ(buf []byte) error {
	return ssz.UnmarshalSSZ(b, buf)
}

// UnmarshalSSZTail unmarshals the BeaconState object and returns the remaining bufferº
func (b *BeaconState) UnmarshalSSZTail(buf []byte) (rest []byte, err error) {
	size := len(buf)
	fixedSize := b.fixedSize()
	if size < fixedSize {
		return nil, ssz.ErrSize
	}

	tail := buf
	var o7, o9, o11, o12, o15, o16, o21, o24, o27 uint64
	marker := ssz.NewOffsetMarker(uint64(size), uint64(fixedSize))

	// Field (0) 'GenesisTime'
	b.GenesisTime, buf = ssz.UnmarshallValue[uint64](buf)

	// Field (1) 'GenesisValidatorsRoot'
	buf = ssz.UnmarshalFixedBytes(b.GenesisValidatorsRoot[:], buf)

	// Field (2) 'Slot'
	{
		var val uint64
		val, buf = ssz.UnmarshallValue[uint64](buf)
		b.Slot = Slot(val)
	}

	// Field (3) 'Fork'
	if buf, err = ssz.UnmarshalFieldTail(&b.Fork, buf); err != nil {
		return
	}

	// Field (4) 'LatestBlockHeader'
	if buf, err = ssz.UnmarshalFieldTail(&b.LatestBlockHeader, buf); err != nil {
		return
	}

	// Field (5) 'BlockRoots'
	b.BlockRoots = make([][]byte, slotsPerHistoricalRoot)
	for ii := uint64(0); ii < slotsPerHistoricalRoot; ii++ {
		b.BlockRoots[ii], buf = ssz.UnmarshalBytes(b.BlockRoots[ii], buf, 32)
	}

	// Field (6) 'StateRoots'
	b.StateRoots = make([][]byte, slotsPerHistoricalRoot)
	for ii := uint64(0); ii < slotsPerHistoricalRoot; ii++ {
		b.StateRoots[ii], buf = ssz.UnmarshalBytes(b.StateRoots[ii], buf, 32)
	}

	// Offset (7) 'HistoricalRoots'
	if o7, buf, err = marker.ReadOffset(buf); err != nil {
		return nil, err
	}

	// Field (8) 'ETH1Data'
	if buf, err = ssz.UnmarshalFieldTail(&b.ETH1Data, buf); err != nil {
		return
	}

	// Offset (9) 'ETH1DataVotes'
	if o9, buf, err = marker.ReadOffset(buf); err != nil {
		return nil, err
	}

	// Field (10) 'ETH1DepositIndex'
	b.ETH1DepositIndex, buf = ssz.UnmarshallValue[uint64](buf)

	// Offset (11) 'Validators'
	if o11, buf, err = marker.ReadOffset(buf); err != nil {
		return nil, err
	}

	// Offset (12) 'Balances'
	if o12, buf, err = marker.ReadOffset(buf); err != nil {
		return nil, err
	}

	// Field (13) 'RANDAOMixes'
	b.RANDAOMixes = make([][]byte, epochsPerHistoricalVector)
	for ii := uint64(0); ii < epochsPerHistoricalVector; ii++ {
		b.RANDAOMixes[ii], buf = ssz.UnmarshalBytes(b.RANDAOMixes[ii], buf, 32)
	}

	// Field (14) 'Slashings'
	b.Slashings = ssz.Extend(b.Slashings, epochsPerSlashingsVector)
	for ii := uint64(0); ii < epochsPerSlashingsVector; ii++ {
		{
			var val uint64
			val, buf = ssz.UnmarshallValue[uint64](buf)
			b.Slashings[ii] = Gwei(val)
		}
	}

	// Offset (15) 'PreviousEpochParticipation'
	if o15, buf, err = marker.ReadOffset(buf); err != nil {
		return nil, err
	}

	// Offset (16) 'CurrentEpochParticipation'
	if o16, buf, err = marker.ReadOffset(buf); err != nil {
		return nil, err
	}

	// Field (17) 'JustificationBits'
	buf = ssz.UnmarshalFixedBytes(b.JustificationBits[:], buf)

	// Field (18) 'PreviousJustifiedCheckpoint'
	if buf, err = ssz.UnmarshalFieldTail(&b.PreviousJustifiedCheckpoint, buf); err != nil {
		return
	}

	// Field (19) 'CurrentJustifiedCheckpoint'
	if buf, err = ssz.UnmarshalFieldTail(&b.CurrentJustifiedCheckpoint, buf); err != nil {
		return
	}

	// Field (20) 'FinalizedCheckpoint'
	if buf, err = ssz.UnmarshalFieldTail(&b.FinalizedCheckpoint, buf); err != nil {
		return
	}

	// Offset (21) 'InactivityScores'
	if o21, buf, err = marker.ReadOffset(buf); err != nil {
		return nil, err
	}

	// Field (22) 'CurrentSyncCommittee'
	if buf, err = ssz.UnmarshalFieldTail(&b.CurrentSyncCommittee, buf); err != nil {
		return
	}

	// Field (23) 'NextSyncCommittee'
	if buf, err = ssz.UnmarshalFieldTail(&b.NextSyncCommittee, buf); err != nil {
		return
	}

	// Offset (24) 'LatestExecutionPayloadHeader'
	if o24, buf, err = marker.ReadOffset(buf); err != nil {
		return nil, err
	}

	// Field (25) 'NextWithdrawalIndex'
	{
		var val uint64
		val, buf = ssz.UnmarshallValue[uint64](buf)
		b.NextWithdrawalIndex = WithdrawalIndex(val)
	}

	// Field (26) 'NextWithdrawalValidatorIndex'
	{
		var val uint64
		val, buf = ssz.UnmarshallValue[uint64](buf)
		b.NextWithdrawalValidatorIndex = ValidatorIndex(val)
	}

	// Offset (27) 'HistoricalSummaries'
	if o27, _, err = marker.ReadOffset(buf); err != nil {
		return nil, err
	}

	// Field (7) 'HistoricalRoots'
	if err = ssz.UnmarshalSliceWithIndexCallback(&b.HistoricalRoots, tail[o7:o9], 32, 16777216, func(ii uint64, buf []byte) (err error) {
		buf = ssz.UnmarshalFixedBytes(b.HistoricalRoots[ii][:], buf)
		return nil
	}); err != nil {
		return nil, err
	}

	// Field (9) 'ETH1DataVotes'
	if err = ssz.UnmarshalSliceSSZ(&b.ETH1DataVotes, tail[o9:o11], eth1DataVotesLimit); err != nil {
		return nil, err
	}

	// Field (11) 'Validators'
	if err = ssz.UnmarshalSliceSSZ(&b.Validators, tail[o11:o12], 1099511627776); err != nil {
		return nil, err
	}

	// Field (12) 'Balances'
	if err = ssz.UnmarshalSliceWithIndexCallback(&b.Balances, tail[o12:o15], 8, 1099511627776, func(ii uint64, buf []byte) (err error) {
		{
			var val uint64
			val, buf = ssz.UnmarshallValue[uint64](buf)
			b.Balances[ii] = Gwei(val)
		}
		return nil
	}); err != nil {
		return nil, err
	}

	// Field (15) 'PreviousEpochParticipation'
	if err = ssz.UnmarshalSliceWithIndexCallback(&b.PreviousEpochParticipation, tail[o15:o16], 1, 1099511627776, func(ii uint64, buf []byte) (err error) {
		{
			var val uint8
			val, buf = ssz.UnmarshallValue[uint8](buf)
			b.PreviousEpochParticipation[ii] = ParticipationFlags(val)
		}
		return nil
	}); err != nil {
		return nil, err
	}

	// Field (16) 'CurrentEpochParticipation'
	if err = ssz.UnmarshalSliceWithIndexCallback(&b.CurrentEpochParticipation, tail[o16:o21], 1, 1099511627776, func(ii uint64, buf []byte) (err error) {
		{
			var val uint8
			val, buf = ssz.UnmarshallValue[uint8](buf)
			b.CurrentEpochParticipation[ii] = ParticipationFlags(val)
		}
		return nil
	}); err != nil {
		return nil, err
	}

	// Field (21) 'InactivityScores'
	if err = ssz.UnmarshalSliceWithIndexCallback(&b.InactivityScores, tail[o21:o24], 8, 1099511627776, func(ii uint64, buf []byte) (err error) {
		b.InactivityScores[ii], buf = ssz.UnmarshallValue[uint64](buf)
		return nil
	}); err != nil {
		return nil, err
	}

	// Field (24) 'LatestExecutionPayloadHeader'
	if err = ssz.UnmarshalField(&b.LatestExecutionPayloadHeader, tail[o24:o27]); err != nil {
		return
	}

	// Field (27) 'HistoricalSummaries'
	if err = ssz.UnmarshalSliceSSZ(&b.HistoricalSummaries, tail[o27:], 16777216); err != nil {
		return nil, err
	}

	return
}

// fixedSize returns the fixed size of the BeaconState object
func (b *BeaconState) fixedSize() int {
	return int((429 + (slotsPerHistoricalRoot * 32) + (slotsPerHistoricalRoot * 32) + (epochsPerHistoricalVector * 32) + (epochsPerSlashingsVector * 8) + (48 + (syncCommitteeSize * 48)) + (48 + (syncCommitteeSize * 48))))
}

// SizeSSZ returns the ssz encoded size in bytes for the BeaconState object
func (b *BeaconState) SizeSSZ() (size int) {
	size = b.fixedSize()

	// Field (7) 'HistoricalRoots'
	size += len(b.HistoricalRoots) * 32

	// Field (9) 'ETH1DataVotes'
	size += len(b.ETH1DataVotes) * 72

	// Field (11) 'Validators'
	size += len(b.Validators) * 121

	// Field (12) 'Balances'
	size += len(b.Balances) * 8

	// Field (15) 'PreviousEpochParticipation'
	size += len(b.PreviousEpochParticipation) * 1

	// Field (16) 'CurrentEpochParticipation'
	size += len(b.CurrentEpochParticipation) * 1

	// Field (21) 'InactivityScores'
	size += len(b.InactivityScores) * 8

	// Field (24) 'LatestExecutionPayloadHeader'
	if b.LatestExecutionPayloadHeader == nil {
		b.LatestExecutionPayloadHeader = new(ExecutionPayloadHeader)
	}
	size += b.LatestExecutionPayloadHeader.SizeSSZ()

	// Field (27) 'HistoricalSummaries'
	size += len(b.HistoricalSummaries) * 64

	return
}

// HashTreeRoot ssz hashes the BeaconState object
func (b *BeaconState) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(b)
}

// HashTreeRootWith ssz hashes the BeaconState object with a hasher
func (b *BeaconState) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'GenesisTime'
	hh.PutUint64(b.GenesisTime)

	// Field (1) 'GenesisValidatorsRoot'
	hh.PutBytes(b.GenesisValidatorsRoot[:])

	// Field (2) 'Slot'
	hh.PutUint64(uint64(b.Slot))

	// Field (3) 'Fork'
	if b.Fork == nil {
		b.Fork = new(Fork)
	}
	if err = b.Fork.HashTreeRootWith(hh); err != nil {
		return
	}

	// Field (4) 'LatestBlockHeader'
	if b.LatestBlockHeader == nil {
		b.LatestBlockHeader = new(BeaconBlockHeader)
	}
	if err = b.LatestBlockHeader.HashTreeRootWith(hh); err != nil {
		return
	}

	// Field (5) 'BlockRoots'
	{
		if size := uint64(len(b.BlockRoots)); size != slotsPerHistoricalRoot {
			err = ssz.ErrVectorLengthFn("BeaconState.BlockRoots", size, slotsPerHistoricalRoot)
			return
		}
		subIndx := hh.Index()
		for _, i := range b.BlockRoots {
			if len(i) != 32 {
				err = ssz.ErrBytesLength
				return
			}
			hh.Append(i)
		}
		hh.Merkleize(subIndx)
	}

	// Field (6) 'StateRoots'
	{
		if size := uint64(len(b.StateRoots)); size != slotsPerHistoricalRoot {
			err = ssz.ErrVectorLengthFn("BeaconState.StateRoots", size, slotsPerHistoricalRoot)
			return
		}
		subIndx := hh.Index()
		for _, i := range b.StateRoots {
			if len(i) != 32 {
				err = ssz.ErrBytesLength
				return
			}
			hh.Append(i)
		}
		hh.Merkleize(subIndx)
	}

	// Field (7) 'HistoricalRoots'
	{
		if size := uint64(len(b.HistoricalRoots)); size > 16777216 {
			err = ssz.ErrListTooBigFn("BeaconState.HistoricalRoots", size, 16777216)
			return
		}
		subIndx := hh.Index()
		for _, i := range b.HistoricalRoots {
			hh.Append(i[:])
		}
		numItems := uint64(len(b.HistoricalRoots))
		hh.MerkleizeWithMixin(subIndx, numItems, 16777216)
	}

	// Field (8) 'ETH1Data'
	if b.ETH1Data == nil {
		b.ETH1Data = new(ETH1Data)
	}
	if err = b.ETH1Data.HashTreeRootWith(hh); err != nil {
		return
	}

	// Field (9) 'ETH1DataVotes'
	{
		subIndx := hh.Index()
		num := uint64(len(b.ETH1DataVotes))
		if num > eth1DataVotesLimit {
			err = ssz.ErrIncorrectListSize
			return
		}
		for _, elem := range b.ETH1DataVotes {
			if err = elem.HashTreeRootWith(hh); err != nil {
				return
			}
		}
		hh.MerkleizeWithMixin(subIndx, num, eth1DataVotesLimit)
	}

	// Field (10) 'ETH1DepositIndex'
	hh.PutUint64(b.ETH1DepositIndex)

	// Field (11) 'Validators'
	{
		subIndx := hh.Index()
		num := uint64(len(b.Validators))
		if num > 1099511627776 {
			err = ssz.ErrIncorrectListSize
			return
		}
		for _, elem := range b.Validators {
			if err = elem.HashTreeRootWith(hh); err != nil {
				return
			}
		}
		hh.MerkleizeWithMixin(subIndx, num, 1099511627776)
	}

	// Field (12) 'Balances'
	{
		if size := uint64(len(b.Balances)); size > 1099511627776 {
			err = ssz.ErrListTooBigFn("BeaconState.Balances", size, 1099511627776)
			return
		}
		subIndx := hh.Index()
		for _, i := range b.Balances {
			hh.AppendUint64(i)
		}
		hh.FillUpTo32()
		numItems := uint64(len(b.Balances))
		hh.MerkleizeWithMixin(subIndx, numItems, ssz.CalculateLimit(1099511627776, numItems, 8))
	}

	// Field (13) 'RANDAOMixes'
	{
		if size := uint64(len(b.RANDAOMixes)); size != epochsPerHistoricalVector {
			err = ssz.ErrVectorLengthFn("BeaconState.RANDAOMixes", size, epochsPerHistoricalVector)
			return
		}
		subIndx := hh.Index()
		for _, i := range b.RANDAOMixes {
			if len(i) != 32 {
				err = ssz.ErrBytesLength
				return
			}
			hh.Append(i)
		}
		hh.Merkleize(subIndx)
	}

	// Field (14) 'Slashings'
	{
		if size := uint64(len(b.Slashings)); size != epochsPerSlashingsVector {
			err = ssz.ErrVectorLengthFn("BeaconState.Slashings", size, epochsPerSlashingsVector)
			return
		}
		subIndx := hh.Index()
		for _, i := range b.Slashings {
			hh.AppendUint64(i)
		}
		hh.Merkleize(subIndx)
	}

	// Field (15) 'PreviousEpochParticipation'
	{
		if size := uint64(len(b.PreviousEpochParticipation)); size > 1099511627776 {
			err = ssz.ErrListTooBigFn("BeaconState.PreviousEpochParticipation", size, 1099511627776)
			return
		}
		subIndx := hh.Index()
		for _, i := range b.PreviousEpochParticipation {
			hh.AppendUint8(i)
		}
		hh.FillUpTo32()
		numItems := uint64(len(b.PreviousEpochParticipation))
		hh.MerkleizeWithMixin(subIndx, numItems, ssz.CalculateLimit(1099511627776, numItems, 1))
	}

	// Field (16) 'CurrentEpochParticipation'
	{
		if size := uint64(len(b.CurrentEpochParticipation)); size > 1099511627776 {
			err = ssz.ErrListTooBigFn("BeaconState.CurrentEpochParticipation", size, 1099511627776)
			return
		}
		subIndx := hh.Index()
		for _, i := range b.CurrentEpochParticipation {
			hh.AppendUint8(i)
		}
		hh.FillUpTo32()
		numItems := uint64(len(b.CurrentEpochParticipation))
		hh.MerkleizeWithMixin(subIndx, numItems, ssz.CalculateLimit(1099511627776, numItems, 1))
	}

	// Field (17) 'JustificationBits'
	hh.PutBytes(b.JustificationBits[:])

	// Field (18) 'PreviousJustifiedCheckpoint'
	if b.PreviousJustifiedCheckpoint == nil {
		b.PreviousJustifiedCheckpoint = new(Checkpoint)
	}
	if err = b.PreviousJustifiedCheckpoint.HashTreeRootWith(hh); err != nil {
		return
	}

	// Field (19) 'CurrentJustifiedCheckpoint'
	if b.CurrentJustifiedCheckpoint == nil {
		b.CurrentJustifiedCheckpoint = new(Checkpoint)
	}
	if err = b.CurrentJustifiedCheckpoint.HashTreeRootWith(hh); err != nil {
		return
	}

	// Field (20) 'FinalizedCheckpoint'
	if b.FinalizedCheckpoint == nil {
		b.FinalizedCheckpoint = new(Checkpoint)
	}
	if err = b.FinalizedCheckpoint.HashTreeRootWith(hh); err != nil {
		return
	}

	// Field (21) 'InactivityScores'
	{
		if size := uint64(len(b.InactivityScores)); size > 1099511627776 {
			err = ssz.ErrListTooBigFn("BeaconState.InactivityScores", size, 1099511627776)
			return
		}
		subIndx := hh.Index()
		for _, i := range b.InactivityScores {
			hh.AppendUint64(i)
		}
		hh.FillUpTo32()
		numItems := uint64(len(b.InactivityScores))
		hh.MerkleizeWithMixin(subIndx, numItems, ssz.CalculateLimit(1099511627776, numItems, 8))
	}

	// Field (22) 'CurrentSyncCommittee'
	if b.CurrentSyncCommittee == nil {
		b.CurrentSyncCommittee = new(SyncCommittee)
	}
	if err = b.CurrentSyncCommittee.HashTreeRootWith(hh); err != nil {
		return
	}

	// Field (23) 'NextSyncCommittee'
	if b.NextSyncCommittee == nil {
		b.NextSyncCommittee = new(SyncCommittee)
	}
	if err = b.NextSyncCommittee.HashTreeRootWith(hh); err != nil {
		return
	}

	// Field (24) 'LatestExecutionPayloadHeader'
	if err = b.LatestExecutionPayloadHeader.HashTreeRootWith(hh); err != nil {
		return
	}

	// Field (25) 'NextWithdrawalIndex'
	hh.PutUint64(uint64(b.NextWithdrawalIndex))

	// Field (26) 'NextWithdrawalValidatorIndex'
	hh.PutUint64(uint64(b.NextWithdrawalValidatorIndex))

	// Field (27) 'HistoricalSummaries'
	{
		subIndx := hh.Index()
		num := uint64(len(b.HistoricalSummaries))
		if num > 16777216 {
			err = ssz.ErrIncorrectListSize
			return
		}
		for _, elem := range b.HistoricalSummaries {
			if err = elem.HashTreeRootWith(hh); err != nil {
				return
			}
		}
		hh.MerkleizeWithMixin(subIndx, num, 16777216)
	}

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the BeaconState object
func (b *BeaconState) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(b)
}
